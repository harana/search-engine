/*
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`activity_slash_check_repo_is_starred_by_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashCheckRepoIsStarredByAuthenticatedUserError {
    Status404(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_delete_repo_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashDeleteRepoSubscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_delete_thread_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashDeleteThreadSubscriptionError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_get_feeds`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashGetFeedsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_get_repo_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashGetRepoSubscriptionError {
    Status404(),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_get_thread`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashGetThreadError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_get_thread_subscription_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashGetThreadSubscriptionForAuthenticatedUserError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_events_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListEventsForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_notifications_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListNotificationsForAuthenticatedUserError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_org_events_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListOrgEventsForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_public_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListPublicEventsError {
    Status403(models::BasicError),
    Status503(models::SecretScanningListAlertsForEnterprise503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_public_events_for_repo_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListPublicEventsForRepoNetworkError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_public_events_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListPublicEventsForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_public_org_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListPublicOrgEventsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_received_events_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListReceivedEventsForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_received_public_events_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListReceivedPublicEventsForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_repo_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListRepoEventsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_repo_notifications_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListRepoNotificationsForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_repos_starred_by_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListReposStarredByAuthenticatedUserError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_repos_starred_by_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListReposStarredByUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_repos_watched_by_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListReposWatchedByUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_stargazers_for_repo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListStargazersForRepoError {
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_watched_repos_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListWatchedReposForAuthenticatedUserError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_list_watchers_for_repo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashListWatchersForRepoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_mark_notifications_as_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashMarkNotificationsAsReadError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_mark_repo_notifications_as_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashMarkRepoNotificationsAsReadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_mark_thread_as_done`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashMarkThreadAsDoneError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_mark_thread_as_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashMarkThreadAsReadError {
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_set_repo_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashSetRepoSubscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_set_thread_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashSetThreadSubscriptionError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_star_repo_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashStarRepoForAuthenticatedUserError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_slash_unstar_repo_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitySlashUnstarRepoForAuthenticatedUserError {
    Status404(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}


/// Whether the authenticated user has starred the repository.
pub async fn activity_slash_check_repo_is_starred_by_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str) -> Result<(), Error<ActivitySlashCheckRepoIsStarredByAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;

    let uri_str = format!("{}/user/starred/{owner}/{repo}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashCheckRepoIsStarredByAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/rest/activity/watching#set-a-repository-subscription).
pub async fn activity_slash_delete_repo_subscription(configuration: &configuration::Configuration, owner: &str, repo: &str) -> Result<(), Error<ActivitySlashDeleteRepoSubscriptionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;

    let uri_str = format!("{}/repos/{owner}/{repo}/subscription", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashDeleteRepoSubscriptionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Mutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/rest/activity/notifications#set-a-thread-subscription) endpoint and set `ignore` to `true`.
pub async fn activity_slash_delete_thread_subscription(configuration: &configuration::Configuration, thread_id: i32) -> Result<(), Error<ActivitySlashDeleteThreadSubscriptionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_thread_id = thread_id;

    let uri_str = format!("{}/notifications/threads/{thread_id}/subscription", configuration.base_path, thread_id=p_thread_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashDeleteThreadSubscriptionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the feeds available to the authenticated user. The response provides a URL for each feed. You can then get a specific feed by sending a request to one of the feed URLs.  *   **Timeline**: The GitHub global public timeline *   **User**: The public timeline for any user, using `uri_template`. For more information, see \"[Hypermedia](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia).\" *   **Current user public**: The public timeline for the authenticated user *   **Current user**: The private timeline for the authenticated user *   **Current user actor**: The private timeline for activity created by the authenticated user *   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of. *   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub.  By default, timeline resources are returned in JSON. You can specify the `application/atom+xml` type in the `Accept` header to return timeline resources in Atom format. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  > [!NOTE] > Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) since current feed URIs use the older, non revocable auth tokens.
pub async fn activity_slash_get_feeds(configuration: &configuration::Configuration, ) -> Result<models::Feed, Error<ActivitySlashGetFeedsError>> {

    let uri_str = format!("{}/feeds", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Feed`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Feed`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashGetFeedsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets information about whether the authenticated user is subscribed to the repository.
pub async fn activity_slash_get_repo_subscription(configuration: &configuration::Configuration, owner: &str, repo: &str) -> Result<models::RepositorySubscription, Error<ActivitySlashGetRepoSubscriptionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;

    let uri_str = format!("{}/repos/{owner}/{repo}/subscription", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RepositorySubscription`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RepositorySubscription`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashGetRepoSubscriptionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets information about a notification thread.
pub async fn activity_slash_get_thread(configuration: &configuration::Configuration, thread_id: i32) -> Result<models::Thread, Error<ActivitySlashGetThreadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_thread_id = thread_id;

    let uri_str = format!("{}/notifications/threads/{thread_id}", configuration.base_path, thread_id=p_thread_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Thread`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Thread`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashGetThreadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/rest/activity/watching#get-a-repository-subscription).  Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
pub async fn activity_slash_get_thread_subscription_for_authenticated_user(configuration: &configuration::Configuration, thread_id: i32) -> Result<models::ThreadSubscription, Error<ActivitySlashGetThreadSubscriptionForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_thread_id = thread_id;

    let uri_str = format!("{}/notifications/threads/{thread_id}/subscription", configuration.base_path, thread_id=p_thread_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ThreadSubscription`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ThreadSubscription`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashGetThreadSubscriptionForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events. _Optional_: use the fine-grained token with following permission set to view private events: \"Events\" user permissions (read).  > [!NOTE] > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
pub async fn activity_slash_list_events_for_authenticated_user(configuration: &configuration::Configuration, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Event>, Error<ActivitySlashListEventsForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/events", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListEventsForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all notifications for the current user, sorted by most recently updated.
pub async fn activity_slash_list_notifications_for_authenticated_user(configuration: &configuration::Configuration, all: Option<bool>, participating: Option<bool>, since: Option<String>, before: Option<String>, page: Option<i32>, per_page: Option<i32>) -> Result<Vec<models::Thread>, Error<ActivitySlashListNotificationsForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_all = all;
    let p_participating = participating;
    let p_since = since;
    let p_before = before;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/notifications", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_participating {
        req_builder = req_builder.query(&[("participating", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Thread&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Thread&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListNotificationsForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This is the user's organization dashboard. You must be authenticated as the user to view this.  > [!NOTE] > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
pub async fn activity_slash_list_org_events_for_authenticated_user(configuration: &configuration::Configuration, username: &str, org: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Event>, Error<ActivitySlashListOrgEventsForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_org = org;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/events/orgs/{org}", configuration.base_path, username=crate::apis::urlencode(p_username), org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListOrgEventsForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
pub async fn activity_slash_list_public_events(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Event>, Error<ActivitySlashListPublicEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/events", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListPublicEventsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
pub async fn activity_slash_list_public_events_for_repo_network(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Event>, Error<ActivitySlashListPublicEventsForRepoNetworkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/networks/{owner}/{repo}/events", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListPublicEventsForRepoNetworkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
pub async fn activity_slash_list_public_events_for_user(configuration: &configuration::Configuration, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Event>, Error<ActivitySlashListPublicEventsForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/events/public", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListPublicEventsForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
pub async fn activity_slash_list_public_org_events(configuration: &configuration::Configuration, org: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Event>, Error<ActivitySlashListPublicOrgEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/orgs/{org}/events", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListPublicOrgEventsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// These are events that you've received by watching repositories and following users. If you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events.  > [!NOTE] > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
pub async fn activity_slash_list_received_events_for_user(configuration: &configuration::Configuration, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Event>, Error<ActivitySlashListReceivedEventsForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/received_events", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListReceivedEventsForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
pub async fn activity_slash_list_received_public_events_for_user(configuration: &configuration::Configuration, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Event>, Error<ActivitySlashListReceivedPublicEventsForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/received_events/public", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListReceivedPublicEventsForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
pub async fn activity_slash_list_repo_events(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Event>, Error<ActivitySlashListRepoEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/events", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListRepoEventsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all notifications for the current user in the specified repository.
pub async fn activity_slash_list_repo_notifications_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, all: Option<bool>, participating: Option<bool>, since: Option<String>, before: Option<String>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Thread>, Error<ActivitySlashListRepoNotificationsForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_all = all;
    let p_participating = participating;
    let p_since = since;
    let p_before = before;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/notifications", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_participating {
        req_builder = req_builder.query(&[("participating", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Thread&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Thread&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListRepoNotificationsForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists repositories the authenticated user has starred.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
pub async fn activity_slash_list_repos_starred_by_authenticated_user(configuration: &configuration::Configuration, sort: Option<&str>, direction: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Repository>, Error<ActivitySlashListReposStarredByAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sort = sort;
    let p_direction = direction;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/starred", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_direction {
        req_builder = req_builder.query(&[("direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Repository&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Repository&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListReposStarredByAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists repositories a user has starred.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
pub async fn activity_slash_list_repos_starred_by_user(configuration: &configuration::Configuration, username: &str, sort: Option<&str>, direction: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<models::ActivityListReposStarredByUser200Response, Error<ActivitySlashListReposStarredByUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_sort = sort;
    let p_direction = direction;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/starred", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_direction {
        req_builder = req_builder.query(&[("direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActivityListReposStarredByUser200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActivityListReposStarredByUser200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListReposStarredByUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists repositories a user is watching.
pub async fn activity_slash_list_repos_watched_by_user(configuration: &configuration::Configuration, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::MinimalRepository>, Error<ActivitySlashListReposWatchedByUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/subscriptions", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MinimalRepository&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MinimalRepository&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListReposWatchedByUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the people that have starred the repository.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
pub async fn activity_slash_list_stargazers_for_repo(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<models::ActivityListStargazersForRepo200Response, Error<ActivitySlashListStargazersForRepoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/stargazers", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActivityListStargazersForRepo200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActivityListStargazersForRepo200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListStargazersForRepoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists repositories the authenticated user is watching.
pub async fn activity_slash_list_watched_repos_for_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::MinimalRepository>, Error<ActivitySlashListWatchedReposForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/subscriptions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MinimalRepository&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MinimalRepository&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListWatchedReposForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the people watching the specified repository.
pub async fn activity_slash_list_watchers_for_repo(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::SimpleUser>, Error<ActivitySlashListWatchersForRepoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/subscribers", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashListWatchersForRepoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Marks all notifications as \"read\" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as \"read.\" To check whether any \"unread\" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
pub async fn activity_slash_mark_notifications_as_read(configuration: &configuration::Configuration, activity_mark_notifications_as_read_request: Option<models::ActivityMarkNotificationsAsReadRequest>) -> Result<models::ActivityMarkNotificationsAsRead202Response, Error<ActivitySlashMarkNotificationsAsReadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_activity_mark_notifications_as_read_request = activity_mark_notifications_as_read_request;

    let uri_str = format!("{}/notifications", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_activity_mark_notifications_as_read_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActivityMarkNotificationsAsRead202Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActivityMarkNotificationsAsRead202Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashMarkNotificationsAsReadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Marks all notifications in a repository as \"read\" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as \"read.\" To check whether any \"unread\" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/rest/activity/notifications#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
pub async fn activity_slash_mark_repo_notifications_as_read(configuration: &configuration::Configuration, owner: &str, repo: &str, activity_mark_repo_notifications_as_read_request: Option<models::ActivityMarkRepoNotificationsAsReadRequest>) -> Result<models::ActivityMarkRepoNotificationsAsRead202Response, Error<ActivitySlashMarkRepoNotificationsAsReadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_activity_mark_repo_notifications_as_read_request = activity_mark_repo_notifications_as_read_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/notifications", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_activity_mark_repo_notifications_as_read_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActivityMarkRepoNotificationsAsRead202Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActivityMarkRepoNotificationsAsRead202Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashMarkRepoNotificationsAsReadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Marks a thread as \"done.\" Marking a thread as \"done\" is equivalent to marking a notification in your notification inbox on GitHub as done: https://github.com/notifications.
pub async fn activity_slash_mark_thread_as_done(configuration: &configuration::Configuration, thread_id: i32) -> Result<(), Error<ActivitySlashMarkThreadAsDoneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_thread_id = thread_id;

    let uri_str = format!("{}/notifications/threads/{thread_id}", configuration.base_path, thread_id=p_thread_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashMarkThreadAsDoneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Marks a thread as \"read.\" Marking a thread as \"read\" is equivalent to clicking a notification in your notification inbox on GitHub: https://github.com/notifications.
pub async fn activity_slash_mark_thread_as_read(configuration: &configuration::Configuration, thread_id: i32) -> Result<(), Error<ActivitySlashMarkThreadAsReadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_thread_id = thread_id;

    let uri_str = format!("{}/notifications/threads/{thread_id}", configuration.base_path, thread_id=p_thread_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashMarkThreadAsReadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore notifications made within a repository, set `ignored` to `true`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/rest/activity/watching#delete-a-repository-subscription) completely.
pub async fn activity_slash_set_repo_subscription(configuration: &configuration::Configuration, owner: &str, repo: &str, activity_set_repo_subscription_request: Option<models::ActivitySetRepoSubscriptionRequest>) -> Result<models::RepositorySubscription, Error<ActivitySlashSetRepoSubscriptionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_activity_set_repo_subscription_request = activity_set_repo_subscription_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/subscription", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_activity_set_repo_subscription_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RepositorySubscription`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RepositorySubscription`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashSetRepoSubscriptionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// If you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.  You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.  Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/rest/activity/notifications#delete-a-thread-subscription) endpoint.
pub async fn activity_slash_set_thread_subscription(configuration: &configuration::Configuration, thread_id: i32, activity_set_thread_subscription_request: Option<models::ActivitySetThreadSubscriptionRequest>) -> Result<models::ThreadSubscription, Error<ActivitySlashSetThreadSubscriptionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_thread_id = thread_id;
    let p_activity_set_thread_subscription_request = activity_set_thread_subscription_request;

    let uri_str = format!("{}/notifications/threads/{thread_id}/subscription", configuration.base_path, thread_id=p_thread_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_activity_set_thread_subscription_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ThreadSubscription`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ThreadSubscription`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashSetThreadSubscriptionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).\"
pub async fn activity_slash_star_repo_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str) -> Result<(), Error<ActivitySlashStarRepoForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;

    let uri_str = format!("{}/user/starred/{owner}/{repo}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashStarRepoForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unstar a repository that the authenticated user has previously starred.
pub async fn activity_slash_unstar_repo_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str) -> Result<(), Error<ActivitySlashUnstarRepoForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;

    let uri_str = format!("{}/user/starred/{owner}/{repo}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitySlashUnstarRepoForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

