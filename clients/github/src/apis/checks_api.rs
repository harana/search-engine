/*
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`checks_slash_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksSlashCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checks_slash_create_suite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksSlashCreateSuiteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checks_slash_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksSlashGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checks_slash_get_suite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksSlashGetSuiteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checks_slash_list_annotations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksSlashListAnnotationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checks_slash_list_for_ref`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksSlashListForRefError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checks_slash_list_for_suite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksSlashListForSuiteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checks_slash_list_suites_for_ref`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksSlashListSuitesForRefError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checks_slash_rerequest_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksSlashRerequestRunError {
    Status403(models::BasicError),
    Status422(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checks_slash_rerequest_suite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksSlashRerequestSuiteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checks_slash_set_suites_preferences`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksSlashSetSuitesPreferencesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checks_slash_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecksSlashUpdateError {
    UnknownValue(serde_json::Value),
}


/// Creates a new check run for a specific commit in a repository.  To create a check run, you must use a GitHub App. OAuth apps and authenticated users are not able to create a check suite.  In a check suite, GitHub limits the number of check runs with the same name to 1000. Once these check runs exceed 1000, GitHub will start to automatically delete older check runs.  > [!NOTE] > The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
pub async fn checks_slash_create(configuration: &configuration::Configuration, owner: &str, repo: &str, checks_create_request: models::ChecksCreateRequest) -> Result<models::CheckRun, Error<ChecksSlashCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_checks_create_request = checks_create_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/check-runs", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_checks_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CheckRun`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CheckRun`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChecksSlashCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a check suite manually. By default, check suites are automatically created when you create a [check run](https://docs.github.com/rest/checks/runs). You only need to use this endpoint for manually creating check suites when you've disabled automatic creation using \"[Update repository preferences for check suites](https://docs.github.com/rest/checks/suites#update-repository-preferences-for-check-suites)\".  > [!NOTE] > The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.  OAuth apps and personal access tokens (classic) cannot use this endpoint.
pub async fn checks_slash_create_suite(configuration: &configuration::Configuration, owner: &str, repo: &str, checks_create_suite_request: models::ChecksCreateSuiteRequest) -> Result<models::CheckSuite, Error<ChecksSlashCreateSuiteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_checks_create_suite_request = checks_create_suite_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/check-suites", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_checks_create_suite_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CheckSuite`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CheckSuite`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChecksSlashCreateSuiteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a single check run using its `id`.  > [!NOTE] > The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint on a private repository.
pub async fn checks_slash_get(configuration: &configuration::Configuration, owner: &str, repo: &str, check_run_id: i32) -> Result<models::CheckRun, Error<ChecksSlashGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_check_run_id = check_run_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/check-runs/{check_run_id}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), check_run_id=p_check_run_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CheckRun`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CheckRun`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChecksSlashGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a single check suite using its `id`.  > [!NOTE] > The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint on a private repository.
pub async fn checks_slash_get_suite(configuration: &configuration::Configuration, owner: &str, repo: &str, check_suite_id: i32) -> Result<models::CheckSuite, Error<ChecksSlashGetSuiteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_check_suite_id = check_suite_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/check-suites/{check_suite_id}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), check_suite_id=p_check_suite_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CheckSuite`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CheckSuite`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChecksSlashGetSuiteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists annotations for a check run using the annotation `id`.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint on a private repository.
pub async fn checks_slash_list_annotations(configuration: &configuration::Configuration, owner: &str, repo: &str, check_run_id: i32, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::CheckAnnotation>, Error<ChecksSlashListAnnotationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_check_run_id = check_run_id;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/check-runs/{check_run_id}/annotations", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), check_run_id=p_check_run_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CheckAnnotation&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CheckAnnotation&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChecksSlashListAnnotationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists check runs for a commit ref. The `ref` can be a SHA, branch name, or a tag name.  > [!NOTE] > The endpoints to manage checks only look for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.  If there are more than 1000 check suites on a single git reference, this endpoint will limit check runs to the 1000 most recent check suites. To iterate over all possible check runs, use the [List check suites for a Git reference](https://docs.github.com/rest/reference/checks#list-check-suites-for-a-git-reference) endpoint and provide the `check_suite_id` parameter to the [List check runs in a check suite](https://docs.github.com/rest/reference/checks#list-check-runs-in-a-check-suite) endpoint.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint on a private repository.
pub async fn checks_slash_list_for_ref(configuration: &configuration::Configuration, owner: &str, repo: &str, r#ref: &str, check_name: Option<&str>, status: Option<&str>, filter: Option<&str>, per_page: Option<i32>, page: Option<i32>, app_id: Option<i32>) -> Result<models::ChecksListForSuite200Response, Error<ChecksSlashListForRefError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_ref = r#ref;
    let p_check_name = check_name;
    let p_status = status;
    let p_filter = filter;
    let p_per_page = per_page;
    let p_page = page;
    let p_app_id = app_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/commits/{ref}/check-runs", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), ref=crate::apis::urlencode(p_ref));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_check_name {
        req_builder = req_builder.query(&[("check_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_app_id {
        req_builder = req_builder.query(&[("app_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChecksListForSuite200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChecksListForSuite200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChecksSlashListForRefError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists check runs for a check suite using its `id`.  > [!NOTE] > The endpoints to manage checks only look for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint on a private repository.
pub async fn checks_slash_list_for_suite(configuration: &configuration::Configuration, owner: &str, repo: &str, check_suite_id: i32, check_name: Option<&str>, status: Option<&str>, filter: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<models::ChecksListForSuite200Response, Error<ChecksSlashListForSuiteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_check_suite_id = check_suite_id;
    let p_check_name = check_name;
    let p_status = status;
    let p_filter = filter;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), check_suite_id=p_check_suite_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_check_name {
        req_builder = req_builder.query(&[("check_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChecksListForSuite200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChecksListForSuite200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChecksSlashListForSuiteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name.  > [!NOTE] > The endpoints to manage checks only look for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint on a private repository.
pub async fn checks_slash_list_suites_for_ref(configuration: &configuration::Configuration, owner: &str, repo: &str, r#ref: &str, app_id: Option<i32>, check_name: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<models::ChecksListSuitesForRef200Response, Error<ChecksSlashListSuitesForRefError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_ref = r#ref;
    let p_app_id = app_id;
    let p_check_name = check_name;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/commits/{ref}/check-suites", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), ref=crate::apis::urlencode(p_ref));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_app_id {
        req_builder = req_builder.query(&[("app_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_check_name {
        req_builder = req_builder.query(&[("check_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChecksListSuitesForRef200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChecksListSuitesForRef200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChecksSlashListSuitesForRefError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Triggers GitHub to rerequest an existing check run, without pushing new code to a repository. This endpoint will trigger the [`check_run` webhook](https://docs.github.com/webhooks/event-payloads/#check_run) event with the action `rerequested`. When a check run is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.  For more information about how to re-run GitHub Actions jobs, see \"[Re-run a job from a workflow run](https://docs.github.com/rest/actions/workflow-runs#re-run-a-job-from-a-workflow-run)\".  OAuth apps and personal access tokens (classic) cannot use this endpoint.
pub async fn checks_slash_rerequest_run(configuration: &configuration::Configuration, owner: &str, repo: &str, check_run_id: i32) -> Result<serde_json::Value, Error<ChecksSlashRerequestRunError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_check_run_id = check_run_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), check_run_id=p_check_run_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChecksSlashRerequestRunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository. This endpoint will trigger the [`check_suite` webhook](https://docs.github.com/webhooks/event-payloads/#check_suite) event with the action `rerequested`. When a check suite is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.  OAuth apps and personal access tokens (classic) cannot use this endpoint.
pub async fn checks_slash_rerequest_suite(configuration: &configuration::Configuration, owner: &str, repo: &str, check_suite_id: i32) -> Result<serde_json::Value, Error<ChecksSlashRerequestSuiteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_check_suite_id = check_suite_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), check_suite_id=p_check_suite_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChecksSlashRerequestSuiteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Changes the default automatic flow when creating check suites. By default, a check suite is automatically created each time code is pushed to a repository. When you disable the automatic creation of check suites, you can manually [Create a check suite](https://docs.github.com/rest/checks/suites#create-a-check-suite). You must have admin permissions in the repository to set preferences for check suites.
pub async fn checks_slash_set_suites_preferences(configuration: &configuration::Configuration, owner: &str, repo: &str, checks_set_suites_preferences_request: models::ChecksSetSuitesPreferencesRequest) -> Result<models::CheckSuitePreference, Error<ChecksSlashSetSuitesPreferencesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_checks_set_suites_preferences_request = checks_set_suites_preferences_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/check-suites/preferences", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_checks_set_suites_preferences_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CheckSuitePreference`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CheckSuitePreference`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChecksSlashSetSuitesPreferencesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a check run for a specific commit in a repository.  > [!NOTE] > The endpoints to manage checks only look for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.  OAuth apps and personal access tokens (classic) cannot use this endpoint.
pub async fn checks_slash_update(configuration: &configuration::Configuration, owner: &str, repo: &str, check_run_id: i32, checks_update_request: models::ChecksUpdateRequest) -> Result<models::CheckRun, Error<ChecksSlashUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_check_run_id = check_run_id;
    let p_checks_update_request = checks_update_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/check-runs/{check_run_id}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), check_run_id=p_check_run_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_checks_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CheckRun`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CheckRun`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChecksSlashUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

