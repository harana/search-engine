/*
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`code_security_slash_attach_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashAttachConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_attach_enterprise_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashAttachEnterpriseConfigurationError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status409(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_create_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashCreateConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_create_configuration_for_enterprise`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashCreateConfigurationForEnterpriseError {
    Status400(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_delete_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashDeleteConfigurationError {
    Status400(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status409(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_delete_configuration_for_enterprise`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashDeleteConfigurationForEnterpriseError {
    Status400(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status409(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_detach_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashDetachConfigurationError {
    Status400(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status409(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_get_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashGetConfigurationError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_get_configuration_for_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashGetConfigurationForRepositoryError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_get_configurations_for_enterprise`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashGetConfigurationsForEnterpriseError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_get_configurations_for_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashGetConfigurationsForOrgError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_get_default_configurations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashGetDefaultConfigurationsError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_get_default_configurations_for_enterprise`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashGetDefaultConfigurationsForEnterpriseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_get_repositories_for_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashGetRepositoriesForConfigurationError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_get_repositories_for_enterprise_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashGetRepositoriesForEnterpriseConfigurationError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_get_single_configuration_for_enterprise`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashGetSingleConfigurationForEnterpriseError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_set_configuration_as_default`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashSetConfigurationAsDefaultError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_set_configuration_as_default_for_enterprise`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashSetConfigurationAsDefaultForEnterpriseError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_update_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashUpdateConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_security_slash_update_enterprise_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeSecuritySlashUpdateEnterpriseConfigurationError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status409(models::BasicError),
    UnknownValue(serde_json::Value),
}


/// Attach a code security configuration to a set of repositories. If the repositories specified are already attached to a configuration, they will be re-attached to the provided configuration.  If insufficient GHAS licenses are available to attach the configuration to a repository, only free features will be enabled.  The authenticated user must be an administrator or security manager for the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
pub async fn code_security_slash_attach_configuration(configuration: &configuration::Configuration, org: &str, configuration_id: i32, code_security_attach_configuration_request: models::CodeSecurityAttachConfigurationRequest) -> Result<serde_json::Value, Error<CodeSecuritySlashAttachConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_configuration_id = configuration_id;
    let p_code_security_attach_configuration_request = code_security_attach_configuration_request;

    let uri_str = format!("{}/orgs/{org}/code-security/configurations/{configuration_id}/attach", configuration.base_path, org=crate::apis::urlencode(p_org), configuration_id=p_configuration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_code_security_attach_configuration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashAttachConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Attaches an enterprise code security configuration to repositories. If the repositories specified are already attached to a configuration, they will be re-attached to the provided configuration.  If insufficient GHAS licenses are available to attach the configuration to a repository, only free features will be enabled.  The authenticated user must be an administrator for the enterprise to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
pub async fn code_security_slash_attach_enterprise_configuration(configuration: &configuration::Configuration, enterprise: &str, configuration_id: i32, code_security_attach_enterprise_configuration_request: models::CodeSecurityAttachEnterpriseConfigurationRequest) -> Result<serde_json::Value, Error<CodeSecuritySlashAttachEnterpriseConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_enterprise = enterprise;
    let p_configuration_id = configuration_id;
    let p_code_security_attach_enterprise_configuration_request = code_security_attach_enterprise_configuration_request;

    let uri_str = format!("{}/enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach", configuration.base_path, enterprise=crate::apis::urlencode(p_enterprise), configuration_id=p_configuration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_code_security_attach_enterprise_configuration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashAttachEnterpriseConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a code security configuration in an organization.  The authenticated user must be an administrator or security manager for the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
pub async fn code_security_slash_create_configuration(configuration: &configuration::Configuration, org: &str, code_security_create_configuration_request: models::CodeSecurityCreateConfigurationRequest) -> Result<models::CodeSecurityConfiguration, Error<CodeSecuritySlashCreateConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_code_security_create_configuration_request = code_security_create_configuration_request;

    let uri_str = format!("{}/orgs/{org}/code-security/configurations", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_code_security_create_configuration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodeSecurityConfiguration`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodeSecurityConfiguration`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashCreateConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a code security configuration in an enterprise.  The authenticated user must be an administrator of the enterprise in order to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
pub async fn code_security_slash_create_configuration_for_enterprise(configuration: &configuration::Configuration, enterprise: &str, code_security_create_configuration_for_enterprise_request: models::CodeSecurityCreateConfigurationForEnterpriseRequest) -> Result<models::CodeSecurityConfiguration, Error<CodeSecuritySlashCreateConfigurationForEnterpriseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_enterprise = enterprise;
    let p_code_security_create_configuration_for_enterprise_request = code_security_create_configuration_for_enterprise_request;

    let uri_str = format!("{}/enterprises/{enterprise}/code-security/configurations", configuration.base_path, enterprise=crate::apis::urlencode(p_enterprise));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_code_security_create_configuration_for_enterprise_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodeSecurityConfiguration`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodeSecurityConfiguration`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashCreateConfigurationForEnterpriseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the desired code security configuration from an organization. Repositories attached to the configuration will retain their settings but will no longer be associated with the configuration.  The authenticated user must be an administrator or security manager for the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
pub async fn code_security_slash_delete_configuration(configuration: &configuration::Configuration, org: &str, configuration_id: i32) -> Result<(), Error<CodeSecuritySlashDeleteConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_configuration_id = configuration_id;

    let uri_str = format!("{}/orgs/{org}/code-security/configurations/{configuration_id}", configuration.base_path, org=crate::apis::urlencode(p_org), configuration_id=p_configuration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashDeleteConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a code security configuration from an enterprise. Repositories attached to the configuration will retain their settings but will no longer be associated with the configuration.  The authenticated user must be an administrator for the enterprise to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
pub async fn code_security_slash_delete_configuration_for_enterprise(configuration: &configuration::Configuration, enterprise: &str, configuration_id: i32) -> Result<(), Error<CodeSecuritySlashDeleteConfigurationForEnterpriseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_enterprise = enterprise;
    let p_configuration_id = configuration_id;

    let uri_str = format!("{}/enterprises/{enterprise}/code-security/configurations/{configuration_id}", configuration.base_path, enterprise=crate::apis::urlencode(p_enterprise), configuration_id=p_configuration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashDeleteConfigurationForEnterpriseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Detach code security configuration(s) from a set of repositories. Repositories will retain their settings but will no longer be associated with the configuration.  The authenticated user must be an administrator or security manager for the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
pub async fn code_security_slash_detach_configuration(configuration: &configuration::Configuration, org: &str, code_security_detach_configuration_request: models::CodeSecurityDetachConfigurationRequest) -> Result<(), Error<CodeSecuritySlashDetachConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_code_security_detach_configuration_request = code_security_detach_configuration_request;

    let uri_str = format!("{}/orgs/{org}/code-security/configurations/detach", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_code_security_detach_configuration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashDetachConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a code security configuration available in an organization.  The authenticated user must be an administrator or security manager for the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
pub async fn code_security_slash_get_configuration(configuration: &configuration::Configuration, org: &str, configuration_id: i32) -> Result<models::CodeSecurityConfiguration, Error<CodeSecuritySlashGetConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_configuration_id = configuration_id;

    let uri_str = format!("{}/orgs/{org}/code-security/configurations/{configuration_id}", configuration.base_path, org=crate::apis::urlencode(p_org), configuration_id=p_configuration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodeSecurityConfiguration`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodeSecurityConfiguration`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashGetConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the code security configuration that manages a repository's code security settings.  The authenticated user must be an administrator or security manager for the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
pub async fn code_security_slash_get_configuration_for_repository(configuration: &configuration::Configuration, owner: &str, repo: &str) -> Result<models::CodeSecurityConfigurationForRepository, Error<CodeSecuritySlashGetConfigurationForRepositoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;

    let uri_str = format!("{}/repos/{owner}/{repo}/code-security-configuration", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodeSecurityConfigurationForRepository`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodeSecurityConfigurationForRepository`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashGetConfigurationForRepositoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all code security configurations available in an enterprise.  The authenticated user must be an administrator of the enterprise in order to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `read:enterprise` scope to use this endpoint.
pub async fn code_security_slash_get_configurations_for_enterprise(configuration: &configuration::Configuration, enterprise: &str, per_page: Option<i32>, before: Option<&str>, after: Option<&str>) -> Result<Vec<models::CodeSecurityConfiguration>, Error<CodeSecuritySlashGetConfigurationsForEnterpriseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_enterprise = enterprise;
    let p_per_page = per_page;
    let p_before = before;
    let p_after = after;

    let uri_str = format!("{}/enterprises/{enterprise}/code-security/configurations", configuration.base_path, enterprise=crate::apis::urlencode(p_enterprise));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CodeSecurityConfiguration&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CodeSecurityConfiguration&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashGetConfigurationsForEnterpriseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all code security configurations available in an organization.  The authenticated user must be an administrator or security manager for the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
pub async fn code_security_slash_get_configurations_for_org(configuration: &configuration::Configuration, org: &str, target_type: Option<&str>, per_page: Option<i32>, before: Option<&str>, after: Option<&str>) -> Result<Vec<models::CodeSecurityConfiguration>, Error<CodeSecuritySlashGetConfigurationsForOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_target_type = target_type;
    let p_per_page = per_page;
    let p_before = before;
    let p_after = after;

    let uri_str = format!("{}/orgs/{org}/code-security/configurations", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_target_type {
        req_builder = req_builder.query(&[("target_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CodeSecurityConfiguration&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CodeSecurityConfiguration&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashGetConfigurationsForOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the default code security configurations for an organization.  The authenticated user must be an administrator or security manager for the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
pub async fn code_security_slash_get_default_configurations(configuration: &configuration::Configuration, org: &str) -> Result<Vec<models::CodeSecurityDefaultConfigurationsInner>, Error<CodeSecuritySlashGetDefaultConfigurationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;

    let uri_str = format!("{}/orgs/{org}/code-security/configurations/defaults", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CodeSecurityDefaultConfigurationsInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CodeSecurityDefaultConfigurationsInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashGetDefaultConfigurationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the default code security configurations for an enterprise.  The authenticated user must be an administrator of the enterprise in order to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `read:enterprise` scope to use this endpoint.
pub async fn code_security_slash_get_default_configurations_for_enterprise(configuration: &configuration::Configuration, enterprise: &str) -> Result<Vec<models::CodeSecurityDefaultConfigurationsInner>, Error<CodeSecuritySlashGetDefaultConfigurationsForEnterpriseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_enterprise = enterprise;

    let uri_str = format!("{}/enterprises/{enterprise}/code-security/configurations/defaults", configuration.base_path, enterprise=crate::apis::urlencode(p_enterprise));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CodeSecurityDefaultConfigurationsInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CodeSecurityDefaultConfigurationsInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashGetDefaultConfigurationsForEnterpriseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the repositories associated with a code security configuration in an organization.  The authenticated user must be an administrator or security manager for the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
pub async fn code_security_slash_get_repositories_for_configuration(configuration: &configuration::Configuration, org: &str, configuration_id: i32, per_page: Option<i32>, before: Option<&str>, after: Option<&str>, status: Option<&str>) -> Result<Vec<models::CodeSecurityConfigurationRepositories>, Error<CodeSecuritySlashGetRepositoriesForConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_configuration_id = configuration_id;
    let p_per_page = per_page;
    let p_before = before;
    let p_after = after;
    let p_status = status;

    let uri_str = format!("{}/orgs/{org}/code-security/configurations/{configuration_id}/repositories", configuration.base_path, org=crate::apis::urlencode(p_org), configuration_id=p_configuration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CodeSecurityConfigurationRepositories&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CodeSecurityConfigurationRepositories&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashGetRepositoriesForConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the repositories associated with an enterprise code security configuration in an organization.  The authenticated user must be an administrator of the enterprise in order to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `read:enterprise` scope to use this endpoint.
pub async fn code_security_slash_get_repositories_for_enterprise_configuration(configuration: &configuration::Configuration, enterprise: &str, configuration_id: i32, per_page: Option<i32>, before: Option<&str>, after: Option<&str>, status: Option<&str>) -> Result<Vec<models::CodeSecurityConfigurationRepositories>, Error<CodeSecuritySlashGetRepositoriesForEnterpriseConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_enterprise = enterprise;
    let p_configuration_id = configuration_id;
    let p_per_page = per_page;
    let p_before = before;
    let p_after = after;
    let p_status = status;

    let uri_str = format!("{}/enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories", configuration.base_path, enterprise=crate::apis::urlencode(p_enterprise), configuration_id=p_configuration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CodeSecurityConfigurationRepositories&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CodeSecurityConfigurationRepositories&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashGetRepositoriesForEnterpriseConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a code security configuration available in an enterprise.  The authenticated user must be an administrator of the enterprise in order to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `read:enterprise` scope to use this endpoint.
pub async fn code_security_slash_get_single_configuration_for_enterprise(configuration: &configuration::Configuration, enterprise: &str, configuration_id: i32) -> Result<models::CodeSecurityConfiguration, Error<CodeSecuritySlashGetSingleConfigurationForEnterpriseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_enterprise = enterprise;
    let p_configuration_id = configuration_id;

    let uri_str = format!("{}/enterprises/{enterprise}/code-security/configurations/{configuration_id}", configuration.base_path, enterprise=crate::apis::urlencode(p_enterprise), configuration_id=p_configuration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodeSecurityConfiguration`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodeSecurityConfiguration`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashGetSingleConfigurationForEnterpriseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets a code security configuration as a default to be applied to new repositories in your organization.  This configuration will be applied to the matching repository type (all, none, public, private and internal) by default when they are created.  The authenticated user must be an administrator or security manager for the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
pub async fn code_security_slash_set_configuration_as_default(configuration: &configuration::Configuration, org: &str, configuration_id: i32, code_security_set_configuration_as_default_for_enterprise_request: models::CodeSecuritySetConfigurationAsDefaultForEnterpriseRequest) -> Result<models::CodeSecuritySetConfigurationAsDefaultForEnterprise200Response, Error<CodeSecuritySlashSetConfigurationAsDefaultError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_configuration_id = configuration_id;
    let p_code_security_set_configuration_as_default_for_enterprise_request = code_security_set_configuration_as_default_for_enterprise_request;

    let uri_str = format!("{}/orgs/{org}/code-security/configurations/{configuration_id}/defaults", configuration.base_path, org=crate::apis::urlencode(p_org), configuration_id=p_configuration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_code_security_set_configuration_as_default_for_enterprise_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodeSecuritySetConfigurationAsDefaultForEnterprise200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodeSecuritySetConfigurationAsDefaultForEnterprise200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashSetConfigurationAsDefaultError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets a code security configuration as a default to be applied to new repositories in your enterprise.  This configuration will be applied by default to the matching repository type when created, but only for organizations within the enterprise that do not already have a default code security configuration set.  The authenticated user must be an administrator for the enterprise to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
pub async fn code_security_slash_set_configuration_as_default_for_enterprise(configuration: &configuration::Configuration, enterprise: &str, configuration_id: i32, code_security_set_configuration_as_default_for_enterprise_request: models::CodeSecuritySetConfigurationAsDefaultForEnterpriseRequest) -> Result<models::CodeSecuritySetConfigurationAsDefaultForEnterprise200Response, Error<CodeSecuritySlashSetConfigurationAsDefaultForEnterpriseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_enterprise = enterprise;
    let p_configuration_id = configuration_id;
    let p_code_security_set_configuration_as_default_for_enterprise_request = code_security_set_configuration_as_default_for_enterprise_request;

    let uri_str = format!("{}/enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults", configuration.base_path, enterprise=crate::apis::urlencode(p_enterprise), configuration_id=p_configuration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_code_security_set_configuration_as_default_for_enterprise_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodeSecuritySetConfigurationAsDefaultForEnterprise200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodeSecuritySetConfigurationAsDefaultForEnterprise200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashSetConfigurationAsDefaultForEnterpriseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a code security configuration in an organization.  The authenticated user must be an administrator or security manager for the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `write:org` scope to use this endpoint.
pub async fn code_security_slash_update_configuration(configuration: &configuration::Configuration, org: &str, configuration_id: i32, code_security_update_configuration_request: models::CodeSecurityUpdateConfigurationRequest) -> Result<models::CodeSecurityConfiguration, Error<CodeSecuritySlashUpdateConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_configuration_id = configuration_id;
    let p_code_security_update_configuration_request = code_security_update_configuration_request;

    let uri_str = format!("{}/orgs/{org}/code-security/configurations/{configuration_id}", configuration.base_path, org=crate::apis::urlencode(p_org), configuration_id=p_configuration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_code_security_update_configuration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodeSecurityConfiguration`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodeSecurityConfiguration`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashUpdateConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a code security configuration in an enterprise.  The authenticated user must be an administrator of the enterprise in order to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `admin:enterprise` scope to use this endpoint.
pub async fn code_security_slash_update_enterprise_configuration(configuration: &configuration::Configuration, enterprise: &str, configuration_id: i32, code_security_update_enterprise_configuration_request: models::CodeSecurityUpdateEnterpriseConfigurationRequest) -> Result<models::CodeSecurityConfiguration, Error<CodeSecuritySlashUpdateEnterpriseConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_enterprise = enterprise;
    let p_configuration_id = configuration_id;
    let p_code_security_update_enterprise_configuration_request = code_security_update_enterprise_configuration_request;

    let uri_str = format!("{}/enterprises/{enterprise}/code-security/configurations/{configuration_id}", configuration.base_path, enterprise=crate::apis::urlencode(p_enterprise), configuration_id=p_configuration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_code_security_update_enterprise_configuration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodeSecurityConfiguration`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodeSecurityConfiguration`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeSecuritySlashUpdateEnterpriseConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

