/*
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`codespaces_slash_add_repository_for_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashAddRepositoryForSecretForAuthenticatedUserError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status500(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_add_selected_repo_to_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashAddSelectedRepoToOrgSecretError {
    Status404(models::BasicError),
    Status409(),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_check_permissions_for_devcontainer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCheckPermissionsForDevcontainerError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status422(models::ValidationError),
    Status503(models::SecretScanningListAlertsForEnterprise503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_codespace_machines_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCodespaceMachinesForAuthenticatedUserError {
    Status500(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_create_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCreateForAuthenticatedUserError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status503(models::SecretScanningListAlertsForEnterprise503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_create_or_update_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCreateOrUpdateOrgSecretError {
    Status404(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_create_or_update_repo_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCreateOrUpdateRepoSecretError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_create_or_update_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCreateOrUpdateSecretForAuthenticatedUserError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_create_with_pr_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCreateWithPrForAuthenticatedUserError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status503(models::SecretScanningListAlertsForEnterprise503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_create_with_repo_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCreateWithRepoForAuthenticatedUserError {
    Status400(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status503(models::SecretScanningListAlertsForEnterprise503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_delete_codespaces_access_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashDeleteCodespacesAccessUsersError {
    Status400(),
    Status404(models::BasicError),
    Status422(models::ValidationError),
    Status500(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_delete_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashDeleteForAuthenticatedUserError {
    Status500(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_delete_from_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashDeleteFromOrganizationError {
    Status500(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_delete_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashDeleteOrgSecretError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_delete_repo_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashDeleteRepoSecretError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_delete_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashDeleteSecretForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_export_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashExportForAuthenticatedUserError {
    Status500(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_codespaces_for_user_in_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetCodespacesForUserInOrgError {
    Status500(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_export_details_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetExportDetailsForAuthenticatedUserError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetForAuthenticatedUserError {
    Status500(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_org_public_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetOrgPublicKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetOrgSecretError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_public_key_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetPublicKeyForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_repo_public_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetRepoPublicKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_repo_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetRepoSecretError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetSecretForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_devcontainers_in_repository_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListDevcontainersInRepositoryForAuthenticatedUserError {
    Status500(models::BasicError),
    Status400(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListForAuthenticatedUserError {
    Status500(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_in_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListInOrganizationError {
    Status500(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_in_repository_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListInRepositoryForAuthenticatedUserError {
    Status500(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_org_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListOrgSecretsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_repo_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListRepoSecretsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_repositories_for_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListRepositoriesForSecretForAuthenticatedUserError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status500(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_secrets_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListSecretsForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_selected_repos_for_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListSelectedReposForOrgSecretError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_pre_flight_with_repo_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashPreFlightWithRepoForAuthenticatedUserError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_publish_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashPublishForAuthenticatedUserError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_remove_repository_for_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashRemoveRepositoryForSecretForAuthenticatedUserError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status500(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_remove_selected_repo_from_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashRemoveSelectedRepoFromOrgSecretError {
    Status404(models::BasicError),
    Status409(),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_repo_machines_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashRepoMachinesForAuthenticatedUserError {
    Status500(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_set_codespaces_access`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashSetCodespacesAccessError {
    Status400(),
    Status404(models::BasicError),
    Status422(models::ValidationError),
    Status500(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_set_codespaces_access_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashSetCodespacesAccessUsersError {
    Status400(),
    Status404(models::BasicError),
    Status422(models::ValidationError),
    Status500(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_set_repositories_for_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashSetRepositoriesForSecretForAuthenticatedUserError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status500(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_set_selected_repos_for_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashSetSelectedReposForOrgSecretError {
    Status404(models::BasicError),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_start_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashStartForAuthenticatedUserError {
    Status500(models::BasicError),
    Status400(models::BasicError),
    Status401(models::BasicError),
    Status402(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status409(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_stop_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashStopForAuthenticatedUserError {
    Status500(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_stop_in_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashStopInOrganizationError {
    Status500(models::BasicError),
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_update_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashUpdateForAuthenticatedUserError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}


/// Adds a repository to the selected repositories for a user's development environment secret.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_add_repository_for_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str, repository_id: i32) -> Result<(), Error<CodespacesSlashAddRepositoryForSecretForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_name = secret_name;
    let p_repository_id = repository_id;

    let uri_str = format!("{}/user/codespaces/secrets/{secret_name}/repositories/{repository_id}", configuration.base_path, secret_name=crate::apis::urlencode(p_secret_name), repository_id=p_repository_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashAddRepositoryForSecretForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a repository to an organization development environment secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret). OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_add_selected_repo_to_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str, repository_id: i32) -> Result<(), Error<CodespacesSlashAddSelectedRepoToOrgSecretError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_secret_name = secret_name;
    let p_repository_id = repository_id;

    let uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}", configuration.base_path, org=crate::apis::urlencode(p_org), secret_name=crate::apis::urlencode(p_secret_name), repository_id=p_repository_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashAddSelectedRepoToOrgSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Checks whether the permissions defined by a given devcontainer configuration have been accepted by the authenticated user.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_check_permissions_for_devcontainer(configuration: &configuration::Configuration, owner: &str, repo: &str, r#ref: &str, devcontainer_path: &str) -> Result<models::CodespacesPermissionsCheckForDevcontainer, Error<CodespacesSlashCheckPermissionsForDevcontainerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_ref = r#ref;
    let p_devcontainer_path = devcontainer_path;

    let uri_str = format!("{}/repos/{owner}/{repo}/codespaces/permissions_check", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ref", &p_ref.to_string())]);
    req_builder = req_builder.query(&[("devcontainer_path", &p_devcontainer_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesPermissionsCheckForDevcontainer`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesPermissionsCheckForDevcontainer`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashCheckPermissionsForDevcontainerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the machine types a codespace can transition to use.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_codespace_machines_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str) -> Result<models::CodespacesRepoMachinesForAuthenticatedUser200Response, Error<CodespacesSlashCodespaceMachinesForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_codespace_name = codespace_name;

    let uri_str = format!("{}/user/codespaces/{codespace_name}/machines", configuration.base_path, codespace_name=crate::apis::urlencode(p_codespace_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesRepoMachinesForAuthenticatedUser200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesRepoMachinesForAuthenticatedUser200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashCodespaceMachinesForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new codespace, owned by the authenticated user.  This endpoint requires either a `repository_id` OR a `pull_request` but not both.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_create_for_authenticated_user(configuration: &configuration::Configuration, codespaces_create_for_authenticated_user_request: models::CodespacesCreateForAuthenticatedUserRequest) -> Result<models::Codespace, Error<CodespacesSlashCreateForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_codespaces_create_for_authenticated_user_request = codespaces_create_for_authenticated_user_request;

    let uri_str = format!("{}/user/codespaces", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_create_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Codespace`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Codespace`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashCreateForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates or updates an organization development environment secret with an encrypted value. Encrypt your secret using [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see \"[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api).\"  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_create_or_update_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str, codespaces_create_or_update_org_secret_request: models::CodespacesCreateOrUpdateOrgSecretRequest) -> Result<serde_json::Value, Error<CodespacesSlashCreateOrUpdateOrgSecretError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_secret_name = secret_name;
    let p_codespaces_create_or_update_org_secret_request = codespaces_create_or_update_org_secret_request;

    let uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}", configuration.base_path, org=crate::apis::urlencode(p_org), secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_create_or_update_org_secret_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashCreateOrUpdateOrgSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates or updates a repository development environment secret with an encrypted value. Encrypt your secret using [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see \"[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api).\"  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint. The associated user must be a repository admin.
pub async fn codespaces_slash_create_or_update_repo_secret(configuration: &configuration::Configuration, owner: &str, repo: &str, secret_name: &str, codespaces_create_or_update_repo_secret_request: models::CodespacesCreateOrUpdateRepoSecretRequest) -> Result<serde_json::Value, Error<CodespacesSlashCreateOrUpdateRepoSecretError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_secret_name = secret_name;
    let p_codespaces_create_or_update_repo_secret_request = codespaces_create_or_update_repo_secret_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/codespaces/secrets/{secret_name}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_create_or_update_repo_secret_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashCreateOrUpdateRepoSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates or updates a development environment secret for a user's codespace with an encrypted value. Encrypt your secret using [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see \"[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api).\"  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_create_or_update_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str, codespaces_create_or_update_secret_for_authenticated_user_request: models::CodespacesCreateOrUpdateSecretForAuthenticatedUserRequest) -> Result<serde_json::Value, Error<CodespacesSlashCreateOrUpdateSecretForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_name = secret_name;
    let p_codespaces_create_or_update_secret_for_authenticated_user_request = codespaces_create_or_update_secret_for_authenticated_user_request;

    let uri_str = format!("{}/user/codespaces/secrets/{secret_name}", configuration.base_path, secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_create_or_update_secret_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashCreateOrUpdateSecretForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a codespace owned by the authenticated user for the specified pull request.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_create_with_pr_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, pull_number: i32, codespaces_create_with_pr_for_authenticated_user_request: Option<models::CodespacesCreateWithPrForAuthenticatedUserRequest>) -> Result<models::Codespace, Error<CodespacesSlashCreateWithPrForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_pull_number = pull_number;
    let p_codespaces_create_with_pr_for_authenticated_user_request = codespaces_create_with_pr_for_authenticated_user_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/pulls/{pull_number}/codespaces", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), pull_number=p_pull_number);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_create_with_pr_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Codespace`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Codespace`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashCreateWithPrForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a codespace owned by the authenticated user in the specified repository.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_create_with_repo_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, codespaces_create_with_repo_for_authenticated_user_request: Option<models::CodespacesCreateWithRepoForAuthenticatedUserRequest>) -> Result<models::Codespace, Error<CodespacesSlashCreateWithRepoForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_codespaces_create_with_repo_for_authenticated_user_request = codespaces_create_with_repo_for_authenticated_user_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/codespaces", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_create_with_repo_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Codespace`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Codespace`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashCreateWithRepoForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Codespaces for the specified users will no longer be billed to the organization.  To use this endpoint, the access settings for the organization must be set to `selected_members`. For information on how to change this setting, see \"[Manage access control for organization codespaces](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces).\"  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_delete_codespaces_access_users(configuration: &configuration::Configuration, org: &str, codespaces_delete_codespaces_access_users_request: models::CodespacesDeleteCodespacesAccessUsersRequest) -> Result<(), Error<CodespacesSlashDeleteCodespacesAccessUsersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_codespaces_delete_codespaces_access_users_request = codespaces_delete_codespaces_access_users_request;

    let uri_str = format!("{}/orgs/{org}/codespaces/access/selected_users", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_delete_codespaces_access_users_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashDeleteCodespacesAccessUsersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a user's codespace.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_delete_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str) -> Result<serde_json::Value, Error<CodespacesSlashDeleteForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_codespace_name = codespace_name;

    let uri_str = format!("{}/user/codespaces/{codespace_name}", configuration.base_path, codespace_name=crate::apis::urlencode(p_codespace_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashDeleteForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a user's codespace.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_delete_from_organization(configuration: &configuration::Configuration, org: &str, username: &str, codespace_name: &str) -> Result<serde_json::Value, Error<CodespacesSlashDeleteFromOrganizationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_username = username;
    let p_codespace_name = codespace_name;

    let uri_str = format!("{}/orgs/{org}/members/{username}/codespaces/{codespace_name}", configuration.base_path, org=crate::apis::urlencode(p_org), username=crate::apis::urlencode(p_username), codespace_name=crate::apis::urlencode(p_codespace_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashDeleteFromOrganizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an organization development environment secret using the secret name.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_delete_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str) -> Result<(), Error<CodespacesSlashDeleteOrgSecretError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_secret_name = secret_name;

    let uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}", configuration.base_path, org=crate::apis::urlencode(p_org), secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashDeleteOrgSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a development environment secret in a repository using the secret name.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint. The associated user must be a repository admin.
pub async fn codespaces_slash_delete_repo_secret(configuration: &configuration::Configuration, owner: &str, repo: &str, secret_name: &str) -> Result<(), Error<CodespacesSlashDeleteRepoSecretError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_secret_name = secret_name;

    let uri_str = format!("{}/repos/{owner}/{repo}/codespaces/secrets/{secret_name}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashDeleteRepoSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a development environment secret from a user's codespaces using the secret name. Deleting the secret will remove access from all codespaces that were allowed to access the secret.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_delete_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str) -> Result<(), Error<CodespacesSlashDeleteSecretForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_name = secret_name;

    let uri_str = format!("{}/user/codespaces/secrets/{secret_name}", configuration.base_path, secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashDeleteSecretForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Triggers an export of the specified codespace and returns a URL and ID where the status of the export can be monitored.  If changes cannot be pushed to the codespace's repository, they will be pushed to a new or previously-existing fork instead.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_export_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str) -> Result<models::CodespaceExportDetails, Error<CodespacesSlashExportForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_codespace_name = codespace_name;

    let uri_str = format!("{}/user/codespaces/{codespace_name}/exports", configuration.base_path, codespace_name=crate::apis::urlencode(p_codespace_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespaceExportDetails`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespaceExportDetails`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashExportForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the codespaces that a member of an organization has for repositories in that organization.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_get_codespaces_for_user_in_org(configuration: &configuration::Configuration, org: &str, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<models::CodespacesListInOrganization200Response, Error<CodespacesSlashGetCodespacesForUserInOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_username = username;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/orgs/{org}/members/{username}/codespaces", configuration.base_path, org=crate::apis::urlencode(p_org), username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesListInOrganization200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesListInOrganization200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashGetCodespacesForUserInOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets information about an export of a codespace.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_get_export_details_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str, export_id: &str) -> Result<models::CodespaceExportDetails, Error<CodespacesSlashGetExportDetailsForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_codespace_name = codespace_name;
    let p_export_id = export_id;

    let uri_str = format!("{}/user/codespaces/{codespace_name}/exports/{export_id}", configuration.base_path, codespace_name=crate::apis::urlencode(p_codespace_name), export_id=crate::apis::urlencode(p_export_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespaceExportDetails`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespaceExportDetails`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashGetExportDetailsForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets information about a user's codespace.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_get_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str) -> Result<models::Codespace, Error<CodespacesSlashGetForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_codespace_name = codespace_name;

    let uri_str = format!("{}/user/codespaces/{codespace_name}", configuration.base_path, codespace_name=crate::apis::urlencode(p_codespace_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Codespace`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Codespace`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashGetForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a public key for an organization, which is required in order to encrypt secrets. You need to encrypt the value of a secret before you can create or update secrets. OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_get_org_public_key(configuration: &configuration::Configuration, org: &str) -> Result<models::CodespacesPublicKey, Error<CodespacesSlashGetOrgPublicKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;

    let uri_str = format!("{}/orgs/{org}/codespaces/secrets/public-key", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesPublicKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesPublicKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashGetOrgPublicKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets an organization development environment secret without revealing its encrypted value.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_get_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str) -> Result<models::CodespacesOrgSecret, Error<CodespacesSlashGetOrgSecretError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_secret_name = secret_name;

    let uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}", configuration.base_path, org=crate::apis::urlencode(p_org), secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesOrgSecret`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesOrgSecret`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashGetOrgSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_get_public_key_for_authenticated_user(configuration: &configuration::Configuration, ) -> Result<models::CodespacesUserPublicKey, Error<CodespacesSlashGetPublicKeyForAuthenticatedUserError>> {

    let uri_str = format!("{}/user/codespaces/secrets/public-key", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesUserPublicKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesUserPublicKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashGetPublicKeyForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets.  If the repository is private, OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
pub async fn codespaces_slash_get_repo_public_key(configuration: &configuration::Configuration, owner: &str, repo: &str) -> Result<models::CodespacesPublicKey, Error<CodespacesSlashGetRepoPublicKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;

    let uri_str = format!("{}/repos/{owner}/{repo}/codespaces/secrets/public-key", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesPublicKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesPublicKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashGetRepoPublicKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a single repository development environment secret without revealing its encrypted value.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
pub async fn codespaces_slash_get_repo_secret(configuration: &configuration::Configuration, owner: &str, repo: &str, secret_name: &str) -> Result<models::RepoCodespacesSecret, Error<CodespacesSlashGetRepoSecretError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_secret_name = secret_name;

    let uri_str = format!("{}/repos/{owner}/{repo}/codespaces/secrets/{secret_name}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RepoCodespacesSecret`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RepoCodespacesSecret`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashGetRepoSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a development environment secret available to a user's codespaces without revealing its encrypted value.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_get_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str) -> Result<models::CodespacesSecret, Error<CodespacesSlashGetSecretForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_name = secret_name;

    let uri_str = format!("{}/user/codespaces/secrets/{secret_name}", configuration.base_path, secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesSecret`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesSecret`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashGetSecretForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the devcontainer.json files associated with a specified repository and the authenticated user. These files specify launchpoint configurations for codespaces created within the repository.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_list_devcontainers_in_repository_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<models::CodespacesListDevcontainersInRepositoryForAuthenticatedUser200Response, Error<CodespacesSlashListDevcontainersInRepositoryForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/codespaces/devcontainers", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesListDevcontainersInRepositoryForAuthenticatedUser200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesListDevcontainersInRepositoryForAuthenticatedUser200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashListDevcontainersInRepositoryForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the authenticated user's codespaces.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_list_for_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>, repository_id: Option<i32>) -> Result<models::CodespacesListInOrganization200Response, Error<CodespacesSlashListForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;
    let p_repository_id = repository_id;

    let uri_str = format!("{}/user/codespaces", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_repository_id {
        req_builder = req_builder.query(&[("repository_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesListInOrganization200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesListInOrganization200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashListForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the codespaces associated to a specified organization.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_list_in_organization(configuration: &configuration::Configuration, org: &str, per_page: Option<i32>, page: Option<i32>) -> Result<models::CodespacesListInOrganization200Response, Error<CodespacesSlashListInOrganizationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/orgs/{org}/codespaces", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesListInOrganization200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesListInOrganization200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashListInOrganizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the codespaces associated to a specified repository and the authenticated user.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_list_in_repository_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<models::CodespacesListInOrganization200Response, Error<CodespacesSlashListInRepositoryForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/codespaces", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesListInOrganization200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesListInOrganization200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashListInRepositoryForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all Codespaces development environment secrets available at the organization-level without revealing their encrypted values.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_list_org_secrets(configuration: &configuration::Configuration, org: &str, per_page: Option<i32>, page: Option<i32>) -> Result<models::CodespacesListOrgSecrets200Response, Error<CodespacesSlashListOrgSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/orgs/{org}/codespaces/secrets", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesListOrgSecrets200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesListOrgSecrets200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashListOrgSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all development environment secrets available in a repository without revealing their encrypted values.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
pub async fn codespaces_slash_list_repo_secrets(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<models::CodespacesListRepoSecrets200Response, Error<CodespacesSlashListRepoSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/codespaces/secrets", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesListRepoSecrets200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesListRepoSecrets200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashListRepoSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the repositories that have been granted the ability to use a user's development environment secret.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_list_repositories_for_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str) -> Result<models::ActionsListSelectedReposForOrgSecret200Response, Error<CodespacesSlashListRepositoriesForSecretForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_name = secret_name;

    let uri_str = format!("{}/user/codespaces/secrets/{secret_name}/repositories", configuration.base_path, secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActionsListSelectedReposForOrgSecret200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActionsListSelectedReposForOrgSecret200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashListRepositoriesForSecretForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all development environment secrets available for a user's codespaces without revealing their encrypted values.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_list_secrets_for_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<models::CodespacesListSecretsForAuthenticatedUser200Response, Error<CodespacesSlashListSecretsForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/codespaces/secrets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesListSecretsForAuthenticatedUser200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesListSecretsForAuthenticatedUser200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashListSecretsForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_list_selected_repos_for_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str, page: Option<i32>, per_page: Option<i32>) -> Result<models::ActionsListSelectedReposForOrgSecret200Response, Error<CodespacesSlashListSelectedReposForOrgSecretError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_secret_name = secret_name;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}/repositories", configuration.base_path, org=crate::apis::urlencode(p_org), secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActionsListSelectedReposForOrgSecret200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActionsListSelectedReposForOrgSecret200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashListSelectedReposForOrgSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the default attributes for codespaces created by the user with the repository.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_pre_flight_with_repo_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, r#ref: Option<&str>, client_ip: Option<&str>) -> Result<models::CodespacesPreFlightWithRepoForAuthenticatedUser200Response, Error<CodespacesSlashPreFlightWithRepoForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_ref = r#ref;
    let p_client_ip = client_ip;

    let uri_str = format!("{}/repos/{owner}/{repo}/codespaces/new", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_ref {
        req_builder = req_builder.query(&[("ref", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_ip {
        req_builder = req_builder.query(&[("client_ip", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesPreFlightWithRepoForAuthenticatedUser200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesPreFlightWithRepoForAuthenticatedUser200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashPreFlightWithRepoForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Publishes an unpublished codespace, creating a new repository and assigning it to the codespace.  The codespace's token is granted write permissions to the repository, allowing the user to push their changes.  This will fail for a codespace that is already published, meaning it has an associated repository.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_publish_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str, codespaces_publish_for_authenticated_user_request: models::CodespacesPublishForAuthenticatedUserRequest) -> Result<models::CodespaceWithFullRepository, Error<CodespacesSlashPublishForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_codespace_name = codespace_name;
    let p_codespaces_publish_for_authenticated_user_request = codespaces_publish_for_authenticated_user_request;

    let uri_str = format!("{}/user/codespaces/{codespace_name}/publish", configuration.base_path, codespace_name=crate::apis::urlencode(p_codespace_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_publish_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespaceWithFullRepository`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespaceWithFullRepository`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashPublishForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a repository from the selected repositories for a user's development environment secret.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_remove_repository_for_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str, repository_id: i32) -> Result<(), Error<CodespacesSlashRemoveRepositoryForSecretForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_name = secret_name;
    let p_repository_id = repository_id;

    let uri_str = format!("{}/user/codespaces/secrets/{secret_name}/repositories/{repository_id}", configuration.base_path, secret_name=crate::apis::urlencode(p_secret_name), repository_id=p_repository_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashRemoveRepositoryForSecretForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a repository from an organization development environment secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_remove_selected_repo_from_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str, repository_id: i32) -> Result<(), Error<CodespacesSlashRemoveSelectedRepoFromOrgSecretError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_secret_name = secret_name;
    let p_repository_id = repository_id;

    let uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}", configuration.base_path, org=crate::apis::urlencode(p_org), secret_name=crate::apis::urlencode(p_secret_name), repository_id=p_repository_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashRemoveSelectedRepoFromOrgSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the machine types available for a given repository based on its configuration.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_repo_machines_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, location: Option<&str>, client_ip: Option<&str>, r#ref: Option<&str>) -> Result<models::CodespacesRepoMachinesForAuthenticatedUser200Response, Error<CodespacesSlashRepoMachinesForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_location = location;
    let p_client_ip = client_ip;
    let p_ref = r#ref;

    let uri_str = format!("{}/repos/{owner}/{repo}/codespaces/machines", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_location {
        req_builder = req_builder.query(&[("location", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_client_ip {
        req_builder = req_builder.query(&[("client_ip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ref {
        req_builder = req_builder.query(&[("ref", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CodespacesRepoMachinesForAuthenticatedUser200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CodespacesRepoMachinesForAuthenticatedUser200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashRepoMachinesForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets which users can access codespaces in an organization. This is synonymous with granting or revoking codespaces access permissions for users according to the visibility. OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_set_codespaces_access(configuration: &configuration::Configuration, org: &str, codespaces_set_codespaces_access_request: models::CodespacesSetCodespacesAccessRequest) -> Result<(), Error<CodespacesSlashSetCodespacesAccessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_codespaces_set_codespaces_access_request = codespaces_set_codespaces_access_request;

    let uri_str = format!("{}/orgs/{org}/codespaces/access", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_set_codespaces_access_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashSetCodespacesAccessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Codespaces for the specified users will be billed to the organization.  To use this endpoint, the access settings for the organization must be set to `selected_members`. For information on how to change this setting, see \"[Manage access control for organization codespaces](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces).\"  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_set_codespaces_access_users(configuration: &configuration::Configuration, org: &str, codespaces_set_codespaces_access_users_request: models::CodespacesSetCodespacesAccessUsersRequest) -> Result<(), Error<CodespacesSlashSetCodespacesAccessUsersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_codespaces_set_codespaces_access_users_request = codespaces_set_codespaces_access_users_request;

    let uri_str = format!("{}/orgs/{org}/codespaces/access/selected_users", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_set_codespaces_access_users_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashSetCodespacesAccessUsersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Select the repositories that will use a user's development environment secret.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_set_repositories_for_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str, codespaces_set_repositories_for_secret_for_authenticated_user_request: models::CodespacesSetRepositoriesForSecretForAuthenticatedUserRequest) -> Result<(), Error<CodespacesSlashSetRepositoriesForSecretForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_name = secret_name;
    let p_codespaces_set_repositories_for_secret_for_authenticated_user_request = codespaces_set_repositories_for_secret_for_authenticated_user_request;

    let uri_str = format!("{}/user/codespaces/secrets/{secret_name}/repositories", configuration.base_path, secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_set_repositories_for_secret_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashSetRepositoriesForSecretForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Replaces all repositories for an organization development environment secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_set_selected_repos_for_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str, codespaces_set_selected_repos_for_org_secret_request: models::CodespacesSetSelectedReposForOrgSecretRequest) -> Result<(), Error<CodespacesSlashSetSelectedReposForOrgSecretError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_secret_name = secret_name;
    let p_codespaces_set_selected_repos_for_org_secret_request = codespaces_set_selected_repos_for_org_secret_request;

    let uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}/repositories", configuration.base_path, org=crate::apis::urlencode(p_org), secret_name=crate::apis::urlencode(p_secret_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_set_selected_repos_for_org_secret_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashSetSelectedReposForOrgSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Starts a user's codespace.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_start_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str) -> Result<models::Codespace, Error<CodespacesSlashStartForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_codespace_name = codespace_name;

    let uri_str = format!("{}/user/codespaces/{codespace_name}/start", configuration.base_path, codespace_name=crate::apis::urlencode(p_codespace_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Codespace`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Codespace`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashStartForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Stops a user's codespace.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_stop_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str) -> Result<models::Codespace, Error<CodespacesSlashStopForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_codespace_name = codespace_name;

    let uri_str = format!("{}/user/codespaces/{codespace_name}/stop", configuration.base_path, codespace_name=crate::apis::urlencode(p_codespace_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Codespace`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Codespace`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashStopForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Stops a user's codespace.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_stop_in_organization(configuration: &configuration::Configuration, org: &str, username: &str, codespace_name: &str) -> Result<models::Codespace, Error<CodespacesSlashStopInOrganizationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_username = username;
    let p_codespace_name = codespace_name;

    let uri_str = format!("{}/orgs/{org}/members/{username}/codespaces/{codespace_name}/stop", configuration.base_path, org=crate::apis::urlencode(p_org), username=crate::apis::urlencode(p_username), codespace_name=crate::apis::urlencode(p_codespace_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Codespace`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Codespace`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashStopInOrganizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a codespace owned by the authenticated user. Currently only the codespace's machine type and recent folders can be modified using this endpoint.  If you specify a new machine type it will be applied the next time your codespace is started.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_update_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str, codespaces_update_for_authenticated_user_request: Option<models::CodespacesUpdateForAuthenticatedUserRequest>) -> Result<models::Codespace, Error<CodespacesSlashUpdateForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_codespace_name = codespace_name;
    let p_codespaces_update_for_authenticated_user_request = codespaces_update_for_authenticated_user_request;

    let uri_str = format!("{}/user/codespaces/{codespace_name}", configuration.base_path, codespace_name=crate::apis::urlencode(p_codespace_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_codespaces_update_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Codespace`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Codespace`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CodespacesSlashUpdateForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

