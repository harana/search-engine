/*
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`gists_slash_check_is_starred`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashCheckIsStarredError {
    Status404(serde_json::Value),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashCreateError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_create_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashCreateCommentError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashDeleteError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_delete_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashDeleteCommentError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_fork`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashForkError {
    Status404(models::BasicError),
    Status422(models::ValidationError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashGetError {
    Status403(models::GistsGet403Response),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_get_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashGetCommentError {
    Status404(models::BasicError),
    Status403(models::GistsGet403Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_get_revision`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashGetRevisionError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashListError {
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_list_comments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashListCommentsError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_list_commits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashListCommitsError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_list_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashListForUserError {
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_list_forks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashListForksError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_list_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashListPublicError {
    Status422(models::ValidationError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_list_starred`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashListStarredError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_star`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashStarError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_unstar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashUnstarError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashUpdateError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gists_slash_update_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GistsSlashUpdateCommentError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}


/// 
pub async fn gists_slash_check_is_starred(configuration: &configuration::Configuration, gist_id: &str) -> Result<(), Error<GistsSlashCheckIsStarredError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;

    let uri_str = format!("{}/gists/{gist_id}/star", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashCheckIsStarredError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allows you to add a new gist with one or more files.  > [!NOTE] > Don't name your files \"gistfile\" with a numerical suffix. This is the format of the automatic naming scheme that Gist uses internally.
pub async fn gists_slash_create(configuration: &configuration::Configuration, gists_create_request: models::GistsCreateRequest) -> Result<models::GistSimple, Error<GistsSlashCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gists_create_request = gists_create_request;

    let uri_str = format!("{}/gists", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_gists_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GistSimple`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GistSimple`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a comment on a gist.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type. - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
pub async fn gists_slash_create_comment(configuration: &configuration::Configuration, gist_id: &str, gists_create_comment_request: models::GistsCreateCommentRequest) -> Result<models::GistComment, Error<GistsSlashCreateCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;
    let p_gists_create_comment_request = gists_create_comment_request;

    let uri_str = format!("{}/gists/{gist_id}/comments", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_gists_create_comment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GistComment`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GistComment`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashCreateCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn gists_slash_delete(configuration: &configuration::Configuration, gist_id: &str) -> Result<(), Error<GistsSlashDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;

    let uri_str = format!("{}/gists/{gist_id}", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn gists_slash_delete_comment(configuration: &configuration::Configuration, gist_id: &str, comment_id: i64) -> Result<(), Error<GistsSlashDeleteCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;
    let p_comment_id = comment_id;

    let uri_str = format!("{}/gists/{gist_id}/comments/{comment_id}", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id), comment_id=p_comment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashDeleteCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn gists_slash_fork(configuration: &configuration::Configuration, gist_id: &str) -> Result<models::BaseGist, Error<GistsSlashForkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;

    let uri_str = format!("{}/gists/{gist_id}/forks", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BaseGist`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BaseGist`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashForkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a specified gist.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type. - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
pub async fn gists_slash_get(configuration: &configuration::Configuration, gist_id: &str) -> Result<models::GistSimple, Error<GistsSlashGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;

    let uri_str = format!("{}/gists/{gist_id}", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GistSimple`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GistSimple`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a comment on a gist.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type. - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
pub async fn gists_slash_get_comment(configuration: &configuration::Configuration, gist_id: &str, comment_id: i64) -> Result<models::GistComment, Error<GistsSlashGetCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;
    let p_comment_id = comment_id;

    let uri_str = format!("{}/gists/{gist_id}/comments/{comment_id}", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id), comment_id=p_comment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GistComment`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GistComment`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashGetCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a specified gist revision.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type. - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
pub async fn gists_slash_get_revision(configuration: &configuration::Configuration, gist_id: &str, sha: &str) -> Result<models::GistSimple, Error<GistsSlashGetRevisionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;
    let p_sha = sha;

    let uri_str = format!("{}/gists/{gist_id}/{sha}", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id), sha=crate::apis::urlencode(p_sha));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GistSimple`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GistSimple`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashGetRevisionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the authenticated user's gists or if called anonymously, this endpoint returns all public gists:
pub async fn gists_slash_list(configuration: &configuration::Configuration, since: Option<String>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::BaseGist>, Error<GistsSlashListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_since = since;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/gists", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BaseGist&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BaseGist&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the comments on a gist.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type. - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
pub async fn gists_slash_list_comments(configuration: &configuration::Configuration, gist_id: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::GistComment>, Error<GistsSlashListCommentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/gists/{gist_id}/comments", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GistComment&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GistComment&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashListCommentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn gists_slash_list_commits(configuration: &configuration::Configuration, gist_id: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::GistCommit>, Error<GistsSlashListCommitsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/gists/{gist_id}/commits", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GistCommit&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GistCommit&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashListCommitsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists public gists for the specified user:
pub async fn gists_slash_list_for_user(configuration: &configuration::Configuration, username: &str, since: Option<String>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::BaseGist>, Error<GistsSlashListForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_since = since;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/gists", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BaseGist&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BaseGist&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashListForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn gists_slash_list_forks(configuration: &configuration::Configuration, gist_id: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::GistSimple>, Error<GistsSlashListForksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/gists/{gist_id}/forks", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GistSimple&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GistSimple&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashListForksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List public gists sorted by most recently updated to least recently updated.  Note: With [pagination](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api), you can fetch up to 3000 gists. For example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
pub async fn gists_slash_list_public(configuration: &configuration::Configuration, since: Option<String>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::BaseGist>, Error<GistsSlashListPublicError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_since = since;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/gists/public", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BaseGist&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BaseGist&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashListPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the authenticated user's starred gists:
pub async fn gists_slash_list_starred(configuration: &configuration::Configuration, since: Option<String>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::BaseGist>, Error<GistsSlashListStarredError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_since = since;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/gists/starred", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BaseGist&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BaseGist&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashListStarredError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).\"
pub async fn gists_slash_star(configuration: &configuration::Configuration, gist_id: &str) -> Result<(), Error<GistsSlashStarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;

    let uri_str = format!("{}/gists/{gist_id}/star", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashStarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn gists_slash_unstar(configuration: &configuration::Configuration, gist_id: &str) -> Result<(), Error<GistsSlashUnstarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;

    let uri_str = format!("{}/gists/{gist_id}/star", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashUnstarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allows you to update a gist's description and to update, delete, or rename gist files. Files from the previous version of the gist that aren't explicitly changed during an edit are unchanged.  At least one of `description` or `files` is required.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type. - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
pub async fn gists_slash_update(configuration: &configuration::Configuration, gist_id: &str, gists_update_request: Option<models::GistsUpdateRequest>) -> Result<models::GistSimple, Error<GistsSlashUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;
    let p_gists_update_request = gists_update_request;

    let uri_str = format!("{}/gists/{gist_id}", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_gists_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GistSimple`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GistSimple`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a comment on a gist.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type. - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
pub async fn gists_slash_update_comment(configuration: &configuration::Configuration, gist_id: &str, comment_id: i64, gists_create_comment_request: models::GistsCreateCommentRequest) -> Result<models::GistComment, Error<GistsSlashUpdateCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gist_id = gist_id;
    let p_comment_id = comment_id;
    let p_gists_create_comment_request = gists_create_comment_request;

    let uri_str = format!("{}/gists/{gist_id}/comments/{comment_id}", configuration.base_path, gist_id=crate::apis::urlencode(p_gist_id), comment_id=p_comment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_gists_create_comment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GistComment`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GistComment`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GistsSlashUpdateCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

