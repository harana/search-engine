/*
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`issues_slash_add_assignees`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashAddAssigneesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_add_labels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashAddLabelsError {
    Status404(models::BasicError),
    Status410(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_add_sub_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashAddSubIssueError {
    Status403(models::BasicError),
    Status410(models::BasicError),
    Status422(models::ValidationError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_check_user_can_be_assigned`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashCheckUserCanBeAssignedError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_check_user_can_be_assigned_to_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashCheckUserCanBeAssignedToIssueError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashCreateError {
    Status400(models::BasicError),
    Status403(models::BasicError),
    Status422(models::ValidationError),
    Status503(models::SecretScanningListAlertsForEnterprise503Response),
    Status404(models::BasicError),
    Status410(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_create_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashCreateCommentError {
    Status403(models::BasicError),
    Status410(models::BasicError),
    Status422(models::ValidationError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_create_label`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashCreateLabelError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_create_milestone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashCreateMilestoneError {
    Status404(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_delete_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashDeleteCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_delete_label`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashDeleteLabelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_delete_milestone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashDeleteMilestoneError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashGetError {
    Status404(models::BasicError),
    Status410(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_get_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashGetCommentError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_get_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashGetEventError {
    Status404(models::BasicError),
    Status410(models::BasicError),
    Status403(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_get_label`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashGetLabelError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_get_milestone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashGetMilestoneError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_assignees`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListAssigneesError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_comments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListCommentsError {
    Status404(models::BasicError),
    Status410(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_comments_for_repo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListCommentsForRepoError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListEventsError {
    Status410(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_events_for_repo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListEventsForRepoError {
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_events_for_timeline`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListEventsForTimelineError {
    Status404(models::BasicError),
    Status410(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListForAuthenticatedUserError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_for_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListForOrgError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_for_repo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListForRepoError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_labels_for_milestone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListLabelsForMilestoneError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_labels_for_repo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListLabelsForRepoError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_labels_on_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListLabelsOnIssueError {
    Status404(models::BasicError),
    Status410(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_milestones`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListMilestonesError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_list_sub_issues`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashListSubIssuesError {
    Status404(models::BasicError),
    Status410(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_lock`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashLockError {
    Status403(models::BasicError),
    Status410(models::BasicError),
    Status404(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_remove_all_labels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashRemoveAllLabelsError {
    Status404(models::BasicError),
    Status410(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_remove_assignees`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashRemoveAssigneesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_remove_label`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashRemoveLabelError {
    Status404(models::BasicError),
    Status410(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_remove_sub_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashRemoveSubIssueError {
    Status400(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_reprioritize_sub_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashReprioritizeSubIssueError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status422(models::ValidationErrorSimple),
    Status503(models::SecretScanningListAlertsForEnterprise503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_set_labels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashSetLabelsError {
    Status404(models::BasicError),
    Status410(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_unlock`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashUnlockError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashUpdateError {
    Status422(models::ValidationError),
    Status503(models::SecretScanningListAlertsForEnterprise503Response),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status410(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_update_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashUpdateCommentError {
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_update_label`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashUpdateLabelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_slash_update_milestone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesSlashUpdateMilestoneError {
    UnknownValue(serde_json::Value),
}


/// Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
pub async fn issues_slash_add_assignees(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, issues_add_assignees_request: Option<models::IssuesAddAssigneesRequest>) -> Result<models::Issue, Error<IssuesSlashAddAssigneesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_issues_add_assignees_request = issues_add_assignees_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/assignees", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_add_assignees_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Issue`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Issue`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashAddAssigneesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds labels to an issue. If you provide an empty array of labels, all labels are removed from the issue. 
pub async fn issues_slash_add_labels(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, issues_add_labels_request: Option<models::IssuesAddLabelsRequest>) -> Result<Vec<models::Label>, Error<IssuesSlashAddLabelsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_issues_add_labels_request = issues_add_labels_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/labels", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_add_labels_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Label&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Label&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashAddLabelsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You can use the REST API to add sub-issues to issues.  Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see \"[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)\" and \"[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).\"  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_add_sub_issue(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, issues_add_sub_issue_request: models::IssuesAddSubIssueRequest) -> Result<models::Issue, Error<IssuesSlashAddSubIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_issues_add_sub_issue_request = issues_add_sub_issue_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/sub_issues", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_add_sub_issue_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Issue`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Issue`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashAddSubIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Checks if a user has permission to be assigned to an issue in this repository.  If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.  Otherwise a `404` status code is returned.
pub async fn issues_slash_check_user_can_be_assigned(configuration: &configuration::Configuration, owner: &str, repo: &str, assignee: &str) -> Result<(), Error<IssuesSlashCheckUserCanBeAssignedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_assignee = assignee;

    let uri_str = format!("{}/repos/{owner}/{repo}/assignees/{assignee}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), assignee=crate::apis::urlencode(p_assignee));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashCheckUserCanBeAssignedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Checks if a user has permission to be assigned to a specific issue.  If the `assignee` can be assigned to this issue, a `204` status code with no content is returned.  Otherwise a `404` status code is returned.
pub async fn issues_slash_check_user_can_be_assigned_to_issue(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, assignee: &str) -> Result<(), Error<IssuesSlashCheckUserCanBeAssignedToIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_assignee = assignee;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number, assignee=crate::apis::urlencode(p_assignee));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashCheckUserCanBeAssignedToIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.  This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see \"[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)\" and \"[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).\"  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_create(configuration: &configuration::Configuration, owner: &str, repo: &str, issues_create_request: models::IssuesCreateRequest) -> Result<models::Issue, Error<IssuesSlashCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issues_create_request = issues_create_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Issue`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Issue`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You can use the REST API to create comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.  This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see \"[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)\" and \"[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).\"  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_create_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, issues_update_comment_request: models::IssuesUpdateCommentRequest) -> Result<models::IssueComment, Error<IssuesSlashCreateCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_issues_update_comment_request = issues_update_comment_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/comments", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_update_comment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueComment`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueComment`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashCreateCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a label for the specified repository with the given name and color. The name and color parameters are required. The color must be a valid [hexadecimal color code](http://www.color-hex.com/).
pub async fn issues_slash_create_label(configuration: &configuration::Configuration, owner: &str, repo: &str, issues_create_label_request: models::IssuesCreateLabelRequest) -> Result<models::Label, Error<IssuesSlashCreateLabelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issues_create_label_request = issues_create_label_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/labels", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_create_label_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Label`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Label`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashCreateLabelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a milestone.
pub async fn issues_slash_create_milestone(configuration: &configuration::Configuration, owner: &str, repo: &str, issues_create_milestone_request: models::IssuesCreateMilestoneRequest) -> Result<models::Milestone, Error<IssuesSlashCreateMilestoneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issues_create_milestone_request = issues_create_milestone_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/milestones", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_create_milestone_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Milestone`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Milestone`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashCreateMilestoneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You can use the REST API to delete comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
pub async fn issues_slash_delete_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, comment_id: i64) -> Result<(), Error<IssuesSlashDeleteCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_comment_id = comment_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/comments/{comment_id}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), comment_id=p_comment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashDeleteCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a label using the given label name.
pub async fn issues_slash_delete_label(configuration: &configuration::Configuration, owner: &str, repo: &str, name: &str) -> Result<(), Error<IssuesSlashDeleteLabelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_name = name;

    let uri_str = format!("{}/repos/{owner}/{repo}/labels/{name}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashDeleteLabelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a milestone using the given milestone number.
pub async fn issues_slash_delete_milestone(configuration: &configuration::Configuration, owner: &str, repo: &str, milestone_number: i32) -> Result<(), Error<IssuesSlashDeleteMilestoneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_milestone_number = milestone_number;

    let uri_str = format!("{}/repos/{owner}/{repo}/milestones/{milestone_number}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), milestone_number=p_milestone_number);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashDeleteMilestoneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The API returns a [`301 Moved Permanently` status](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api#follow-redirects) if the issue was [transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.  > [!NOTE] > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)\" endpoint.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_get(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32) -> Result<models::Issue, Error<IssuesSlashGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Issue`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Issue`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You can use the REST API to get comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_get_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, comment_id: i64) -> Result<models::IssueComment, Error<IssuesSlashGetCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_comment_id = comment_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/comments/{comment_id}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), comment_id=p_comment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueComment`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueComment`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashGetCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a single event by the event id.
pub async fn issues_slash_get_event(configuration: &configuration::Configuration, owner: &str, repo: &str, event_id: i32) -> Result<models::IssueEvent, Error<IssuesSlashGetEventError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_event_id = event_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/events/{event_id}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), event_id=p_event_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueEvent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueEvent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashGetEventError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a label using the given name.
pub async fn issues_slash_get_label(configuration: &configuration::Configuration, owner: &str, repo: &str, name: &str) -> Result<models::Label, Error<IssuesSlashGetLabelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_name = name;

    let uri_str = format!("{}/repos/{owner}/{repo}/labels/{name}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Label`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Label`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashGetLabelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a milestone using the given milestone number.
pub async fn issues_slash_get_milestone(configuration: &configuration::Configuration, owner: &str, repo: &str, milestone_number: i32) -> Result<models::Milestone, Error<IssuesSlashGetMilestoneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_milestone_number = milestone_number;

    let uri_str = format!("{}/repos/{owner}/{repo}/milestones/{milestone_number}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), milestone_number=p_milestone_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Milestone`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Milestone`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashGetMilestoneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List issues assigned to the authenticated user across all visible repositories including owned repositories, member repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not necessarily assigned to you.  > [!NOTE] > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)\" endpoint.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_list(configuration: &configuration::Configuration, filter: Option<&str>, state: Option<&str>, labels: Option<&str>, sort: Option<&str>, direction: Option<&str>, since: Option<String>, collab: Option<bool>, orgs: Option<bool>, owned: Option<bool>, pulls: Option<bool>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Issue>, Error<IssuesSlashListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_filter = filter;
    let p_state = state;
    let p_labels = labels;
    let p_sort = sort;
    let p_direction = direction;
    let p_since = since;
    let p_collab = collab;
    let p_orgs = orgs;
    let p_owned = owned;
    let p_pulls = pulls;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/issues", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_labels {
        req_builder = req_builder.query(&[("labels", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_direction {
        req_builder = req_builder.query(&[("direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_collab {
        req_builder = req_builder.query(&[("collab", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_orgs {
        req_builder = req_builder.query(&[("orgs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_owned {
        req_builder = req_builder.query(&[("owned", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pulls {
        req_builder = req_builder.query(&[("pulls", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Issue&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Issue&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the [available assignees](https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
pub async fn issues_slash_list_assignees(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::SimpleUser>, Error<IssuesSlashListAssigneesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/assignees", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListAssigneesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You can use the REST API to list comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.  Issue comments are ordered by ascending ID.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_list_comments(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, since: Option<String>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::IssueComment>, Error<IssuesSlashListCommentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_since = since;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/comments", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::IssueComment&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::IssueComment&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListCommentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You can use the REST API to list comments on issues and pull requests for a repository. Every pull request is an issue, but not every issue is a pull request.  By default, issue comments are ordered by ascending ID.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_list_comments_for_repo(configuration: &configuration::Configuration, owner: &str, repo: &str, sort: Option<&str>, direction: Option<&str>, since: Option<String>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::IssueComment>, Error<IssuesSlashListCommentsForRepoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_sort = sort;
    let p_direction = direction;
    let p_since = since;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/comments", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_direction {
        req_builder = req_builder.query(&[("direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::IssueComment&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::IssueComment&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListCommentsForRepoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all events for an issue.
pub async fn issues_slash_list_events(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::IssueEventForIssue>, Error<IssuesSlashListEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/events", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::IssueEventForIssue&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::IssueEventForIssue&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListEventsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists events for a repository.
pub async fn issues_slash_list_events_for_repo(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::IssueEvent>, Error<IssuesSlashListEventsForRepoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/events", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::IssueEvent&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::IssueEvent&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListEventsForRepoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all timeline events for an issue.
pub async fn issues_slash_list_events_for_timeline(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::TimelineIssueEvents>, Error<IssuesSlashListEventsForTimelineError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/timeline", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TimelineIssueEvents&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TimelineIssueEvents&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListEventsForTimelineError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List issues across owned and member repositories assigned to the authenticated user.  > [!NOTE] > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)\" endpoint.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_list_for_authenticated_user(configuration: &configuration::Configuration, filter: Option<&str>, state: Option<&str>, labels: Option<&str>, sort: Option<&str>, direction: Option<&str>, since: Option<String>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Issue>, Error<IssuesSlashListForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_filter = filter;
    let p_state = state;
    let p_labels = labels;
    let p_sort = sort;
    let p_direction = direction;
    let p_since = since;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/issues", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_labels {
        req_builder = req_builder.query(&[("labels", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_direction {
        req_builder = req_builder.query(&[("direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Issue&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Issue&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List issues in an organization assigned to the authenticated user.  > [!NOTE] > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)\" endpoint.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_list_for_org(configuration: &configuration::Configuration, org: &str, filter: Option<&str>, state: Option<&str>, labels: Option<&str>, r#type: Option<&str>, sort: Option<&str>, direction: Option<&str>, since: Option<String>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Issue>, Error<IssuesSlashListForOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_filter = filter;
    let p_state = state;
    let p_labels = labels;
    let p_type = r#type;
    let p_sort = sort;
    let p_direction = direction;
    let p_since = since;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/orgs/{org}/issues", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_labels {
        req_builder = req_builder.query(&[("labels", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_direction {
        req_builder = req_builder.query(&[("direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Issue&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Issue&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListForOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List issues in a repository. Only open issues will be listed.  > [!NOTE] > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)\" endpoint.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_list_for_repo(configuration: &configuration::Configuration, owner: &str, repo: &str, milestone: Option<&str>, state: Option<&str>, assignee: Option<&str>, r#type: Option<&str>, creator: Option<&str>, mentioned: Option<&str>, labels: Option<&str>, sort: Option<&str>, direction: Option<&str>, since: Option<String>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Issue>, Error<IssuesSlashListForRepoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_milestone = milestone;
    let p_state = state;
    let p_assignee = assignee;
    let p_type = r#type;
    let p_creator = creator;
    let p_mentioned = mentioned;
    let p_labels = labels;
    let p_sort = sort;
    let p_direction = direction;
    let p_since = since;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_milestone {
        req_builder = req_builder.query(&[("milestone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_assignee {
        req_builder = req_builder.query(&[("assignee", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_creator {
        req_builder = req_builder.query(&[("creator", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_mentioned {
        req_builder = req_builder.query(&[("mentioned", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_labels {
        req_builder = req_builder.query(&[("labels", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_direction {
        req_builder = req_builder.query(&[("direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Issue&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Issue&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListForRepoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists labels for issues in a milestone.
pub async fn issues_slash_list_labels_for_milestone(configuration: &configuration::Configuration, owner: &str, repo: &str, milestone_number: i32, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Label>, Error<IssuesSlashListLabelsForMilestoneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_milestone_number = milestone_number;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/milestones/{milestone_number}/labels", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), milestone_number=p_milestone_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Label&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Label&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListLabelsForMilestoneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all labels for a repository.
pub async fn issues_slash_list_labels_for_repo(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Label>, Error<IssuesSlashListLabelsForRepoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/labels", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Label&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Label&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListLabelsForRepoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all labels for an issue.
pub async fn issues_slash_list_labels_on_issue(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Label>, Error<IssuesSlashListLabelsOnIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/labels", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Label&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Label&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListLabelsOnIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists milestones for a repository.
pub async fn issues_slash_list_milestones(configuration: &configuration::Configuration, owner: &str, repo: &str, state: Option<&str>, sort: Option<&str>, direction: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Milestone>, Error<IssuesSlashListMilestonesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_state = state;
    let p_sort = sort;
    let p_direction = direction;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/milestones", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_direction {
        req_builder = req_builder.query(&[("direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Milestone&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Milestone&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListMilestonesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You can use the REST API to list the sub-issues on an issue.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_list_sub_issues(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Issue>, Error<IssuesSlashListSubIssuesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/sub_issues", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Issue&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Issue&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashListSubIssuesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Users with push access can lock an issue or pull request's conversation.  Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).\"
pub async fn issues_slash_lock(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, issues_lock_request: Option<models::IssuesLockRequest>) -> Result<(), Error<IssuesSlashLockError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_issues_lock_request = issues_lock_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/lock", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_lock_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashLockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes all labels from an issue.
pub async fn issues_slash_remove_all_labels(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32) -> Result<(), Error<IssuesSlashRemoveAllLabelsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/labels", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashRemoveAllLabelsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes one or more assignees from an issue.
pub async fn issues_slash_remove_assignees(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, issues_remove_assignees_request: Option<models::IssuesRemoveAssigneesRequest>) -> Result<models::Issue, Error<IssuesSlashRemoveAssigneesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_issues_remove_assignees_request = issues_remove_assignees_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/assignees", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_remove_assignees_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Issue`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Issue`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashRemoveAssigneesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist.
pub async fn issues_slash_remove_label(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, name: &str) -> Result<Vec<models::Label>, Error<IssuesSlashRemoveLabelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_name = name;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Label&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Label&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashRemoveLabelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You can use the REST API to remove a sub-issue from an issue. Removing content too quickly using this endpoint may result in secondary rate limiting. For more information, see \"[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)\" and \"[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api).\" This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\" - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass a specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_remove_sub_issue(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, issues_remove_sub_issue_request: models::IssuesRemoveSubIssueRequest) -> Result<models::Issue, Error<IssuesSlashRemoveSubIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_issues_remove_sub_issue_request = issues_remove_sub_issue_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/sub_issue", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_remove_sub_issue_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Issue`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Issue`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashRemoveSubIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You can use the REST API to reprioritize a sub-issue to a different position in the parent list.
pub async fn issues_slash_reprioritize_sub_issue(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, issues_reprioritize_sub_issue_request: models::IssuesReprioritizeSubIssueRequest) -> Result<models::Issue, Error<IssuesSlashReprioritizeSubIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_issues_reprioritize_sub_issue_request = issues_reprioritize_sub_issue_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_reprioritize_sub_issue_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Issue`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Issue`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashReprioritizeSubIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes any previous labels and sets the new labels for an issue.
pub async fn issues_slash_set_labels(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, issues_set_labels_request: Option<models::IssuesSetLabelsRequest>) -> Result<Vec<models::Label>, Error<IssuesSlashSetLabelsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_issues_set_labels_request = issues_set_labels_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/labels", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_set_labels_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Label&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Label&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashSetLabelsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Users with push access can unlock an issue's conversation.
pub async fn issues_slash_unlock(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32) -> Result<(), Error<IssuesSlashUnlockError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/lock", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashUnlockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Issue owners and users with push access or Triage role can edit an issue.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_update(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, issues_update_request: Option<models::IssuesUpdateRequest>) -> Result<models::Issue, Error<IssuesSlashUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_issues_update_request = issues_update_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Issue`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Issue`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You can use the REST API to update comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.  This endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"  - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type. - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`. - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`. - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
pub async fn issues_slash_update_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, comment_id: i64, issues_update_comment_request: models::IssuesUpdateCommentRequest) -> Result<models::IssueComment, Error<IssuesSlashUpdateCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_comment_id = comment_id;
    let p_issues_update_comment_request = issues_update_comment_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/comments/{comment_id}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), comment_id=p_comment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_update_comment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueComment`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueComment`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashUpdateCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a label using the given label name.
pub async fn issues_slash_update_label(configuration: &configuration::Configuration, owner: &str, repo: &str, name: &str, issues_update_label_request: Option<models::IssuesUpdateLabelRequest>) -> Result<models::Label, Error<IssuesSlashUpdateLabelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_name = name;
    let p_issues_update_label_request = issues_update_label_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/labels/{name}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_update_label_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Label`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Label`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashUpdateLabelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn issues_slash_update_milestone(configuration: &configuration::Configuration, owner: &str, repo: &str, milestone_number: i32, issues_update_milestone_request: Option<models::IssuesUpdateMilestoneRequest>) -> Result<models::Milestone, Error<IssuesSlashUpdateMilestoneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_milestone_number = milestone_number;
    let p_issues_update_milestone_request = issues_update_milestone_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/milestones/{milestone_number}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), milestone_number=p_milestone_number);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_issues_update_milestone_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Milestone`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Milestone`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssuesSlashUpdateMilestoneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

