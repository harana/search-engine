/*
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`packages_slash_delete_package_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashDeletePackageForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_delete_package_for_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashDeletePackageForOrgError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_delete_package_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashDeletePackageForUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_delete_package_version_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashDeletePackageVersionForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_delete_package_version_for_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashDeletePackageVersionForOrgError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_delete_package_version_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashDeletePackageVersionForUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_get_all_package_versions_for_package_owned_by_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashGetAllPackageVersionsForPackageOwnedByAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_get_all_package_versions_for_package_owned_by_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashGetAllPackageVersionsForPackageOwnedByOrgError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_get_all_package_versions_for_package_owned_by_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashGetAllPackageVersionsForPackageOwnedByUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_get_package_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashGetPackageForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_get_package_for_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashGetPackageForOrganizationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_get_package_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashGetPackageForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_get_package_version_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashGetPackageVersionForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_get_package_version_for_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashGetPackageVersionForOrganizationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_get_package_version_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashGetPackageVersionForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_list_docker_migration_conflicting_packages_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashListDockerMigrationConflictingPackagesForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_list_docker_migration_conflicting_packages_for_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashListDockerMigrationConflictingPackagesForOrganizationError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_list_docker_migration_conflicting_packages_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashListDockerMigrationConflictingPackagesForUserError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_list_packages_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashListPackagesForAuthenticatedUserError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_list_packages_for_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashListPackagesForOrganizationError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_list_packages_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashListPackagesForUserError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_restore_package_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashRestorePackageForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_restore_package_for_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashRestorePackageForOrgError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_restore_package_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashRestorePackageForUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_restore_package_version_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashRestorePackageVersionForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_restore_package_version_for_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashRestorePackageVersionForOrgError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_slash_restore_package_version_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesSlashRestorePackageVersionForUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}


/// Deletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_delete_package_for_authenticated_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str) -> Result<(), Error<PackagesSlashDeletePackageForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;

    let uri_str = format!("{}/user/packages/{package_type}/{package_name}", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashDeletePackageForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  The authenticated user must have admin permissions in the organization to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_delete_package_for_org(configuration: &configuration::Configuration, package_type: &str, package_name: &str, org: &str) -> Result<(), Error<PackagesSlashDeletePackageForOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_org = org;

    let uri_str = format!("{}/orgs/{org}/packages/{package_type}/{package_name}", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashDeletePackageForOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an entire package for a user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_delete_package_for_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str, username: &str) -> Result<(), Error<PackagesSlashDeletePackageForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_username = username;

    let uri_str = format!("{}/users/{username}/packages/{package_type}/{package_name}", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashDeletePackageForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  The authenticated user must have admin permissions in the organization to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_delete_package_version_for_authenticated_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str, package_version_id: i32) -> Result<(), Error<PackagesSlashDeletePackageVersionForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_package_version_id = package_version_id;

    let uri_str = format!("{}/user/packages/{package_type}/{package_name}/versions/{package_version_id}", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), package_version_id=p_package_version_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashDeletePackageVersionForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  The authenticated user must have admin permissions in the organization to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_delete_package_version_for_org(configuration: &configuration::Configuration, package_type: &str, package_name: &str, org: &str, package_version_id: i32) -> Result<(), Error<PackagesSlashDeletePackageVersionForOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_org = org;
    let p_package_version_id = package_version_id;

    let uri_str = format!("{}/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), org=crate::apis::urlencode(p_org), package_version_id=p_package_version_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashDeletePackageVersionForOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a specific package version for a user. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_delete_package_version_for_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str, username: &str, package_version_id: i32) -> Result<(), Error<PackagesSlashDeletePackageVersionForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_username = username;
    let p_package_version_id = package_version_id;

    let uri_str = format!("{}/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), username=crate::apis::urlencode(p_username), package_version_id=p_package_version_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashDeletePackageVersionForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists package versions for a package owned by the authenticated user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_get_all_package_versions_for_package_owned_by_authenticated_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str, page: Option<i32>, per_page: Option<i32>, state: Option<&str>) -> Result<Vec<models::PackageVersion>, Error<PackagesSlashGetAllPackageVersionsForPackageOwnedByAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_page = page;
    let p_per_page = per_page;
    let p_state = state;

    let uri_str = format!("{}/user/packages/{package_type}/{package_name}/versions", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PackageVersion&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PackageVersion&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashGetAllPackageVersionsForPackageOwnedByAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists package versions for a package owned by an organization.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_get_all_package_versions_for_package_owned_by_org(configuration: &configuration::Configuration, package_type: &str, package_name: &str, org: &str, page: Option<i32>, per_page: Option<i32>, state: Option<&str>) -> Result<Vec<models::PackageVersion>, Error<PackagesSlashGetAllPackageVersionsForPackageOwnedByOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_org = org;
    let p_page = page;
    let p_per_page = per_page;
    let p_state = state;

    let uri_str = format!("{}/orgs/{org}/packages/{package_type}/{package_name}/versions", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PackageVersion&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PackageVersion&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashGetAllPackageVersionsForPackageOwnedByOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists package versions for a public package owned by a specified user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_get_all_package_versions_for_package_owned_by_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str, username: &str) -> Result<Vec<models::PackageVersion>, Error<PackagesSlashGetAllPackageVersionsForPackageOwnedByUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_username = username;

    let uri_str = format!("{}/users/{username}/packages/{package_type}/{package_name}/versions", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PackageVersion&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PackageVersion&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashGetAllPackageVersionsForPackageOwnedByUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a specific package for a package owned by the authenticated user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_get_package_for_authenticated_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str) -> Result<models::Package, Error<PackagesSlashGetPackageForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;

    let uri_str = format!("{}/user/packages/{package_type}/{package_name}", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Package`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Package`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashGetPackageForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a specific package in an organization.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_get_package_for_organization(configuration: &configuration::Configuration, package_type: &str, package_name: &str, org: &str) -> Result<models::Package, Error<PackagesSlashGetPackageForOrganizationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_org = org;

    let uri_str = format!("{}/orgs/{org}/packages/{package_type}/{package_name}", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Package`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Package`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashGetPackageForOrganizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a specific package metadata for a public package owned by a user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_get_package_for_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str, username: &str) -> Result<models::Package, Error<PackagesSlashGetPackageForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_username = username;

    let uri_str = format!("{}/users/{username}/packages/{package_type}/{package_name}", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Package`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Package`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashGetPackageForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a specific package version for a package owned by the authenticated user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_get_package_version_for_authenticated_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str, package_version_id: i32) -> Result<models::PackageVersion, Error<PackagesSlashGetPackageVersionForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_package_version_id = package_version_id;

    let uri_str = format!("{}/user/packages/{package_type}/{package_name}/versions/{package_version_id}", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), package_version_id=p_package_version_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PackageVersion`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PackageVersion`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashGetPackageVersionForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a specific package version in an organization.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_get_package_version_for_organization(configuration: &configuration::Configuration, package_type: &str, package_name: &str, org: &str, package_version_id: i32) -> Result<models::PackageVersion, Error<PackagesSlashGetPackageVersionForOrganizationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_org = org;
    let p_package_version_id = package_version_id;

    let uri_str = format!("{}/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), org=crate::apis::urlencode(p_org), package_version_id=p_package_version_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PackageVersion`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PackageVersion`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashGetPackageVersionForOrganizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a specific package version for a public package owned by a specified user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_get_package_version_for_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str, package_version_id: i32, username: &str) -> Result<models::PackageVersion, Error<PackagesSlashGetPackageVersionForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_package_version_id = package_version_id;
    let p_username = username;

    let uri_str = format!("{}/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), package_version_id=p_package_version_id, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PackageVersion`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PackageVersion`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashGetPackageVersionForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all packages that are owned by the authenticated user within the user's namespace, and that encountered a conflict during a Docker migration.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint.
pub async fn packages_slash_list_docker_migration_conflicting_packages_for_authenticated_user(configuration: &configuration::Configuration, ) -> Result<Vec<models::Package>, Error<PackagesSlashListDockerMigrationConflictingPackagesForAuthenticatedUserError>> {

    let uri_str = format!("{}/user/docker/conflicts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Package&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Package&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashListDockerMigrationConflictingPackagesForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all packages that are in a specific organization, are readable by the requesting user, and that encountered a conflict during a Docker migration.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint.
pub async fn packages_slash_list_docker_migration_conflicting_packages_for_organization(configuration: &configuration::Configuration, org: &str) -> Result<Vec<models::Package>, Error<PackagesSlashListDockerMigrationConflictingPackagesForOrganizationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;

    let uri_str = format!("{}/orgs/{org}/docker/conflicts", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Package&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Package&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashListDockerMigrationConflictingPackagesForOrganizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all packages that are in a specific user's namespace, that the requesting user has access to, and that encountered a conflict during Docker migration.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint.
pub async fn packages_slash_list_docker_migration_conflicting_packages_for_user(configuration: &configuration::Configuration, username: &str) -> Result<Vec<models::Package>, Error<PackagesSlashListDockerMigrationConflictingPackagesForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/users/{username}/docker/conflicts", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Package&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Package&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashListDockerMigrationConflictingPackagesForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists packages owned by the authenticated user within the user's namespace.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_list_packages_for_authenticated_user(configuration: &configuration::Configuration, package_type: &str, visibility: Option<&str>, page: Option<i32>, per_page: Option<i32>) -> Result<Vec<models::Package>, Error<PackagesSlashListPackagesForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_visibility = visibility;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/user/packages", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("package_type", &p_package_type.to_string())]);
    if let Some(ref param_value) = p_visibility {
        req_builder = req_builder.query(&[("visibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Package&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Package&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashListPackagesForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists packages in an organization readable by the user.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_list_packages_for_organization(configuration: &configuration::Configuration, package_type: &str, org: &str, visibility: Option<&str>, page: Option<i32>, per_page: Option<i32>) -> Result<Vec<models::Package>, Error<PackagesSlashListPackagesForOrganizationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_org = org;
    let p_visibility = visibility;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/orgs/{org}/packages", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("package_type", &p_package_type.to_string())]);
    if let Some(ref param_value) = p_visibility {
        req_builder = req_builder.query(&[("visibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Package&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Package&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashListPackagesForOrganizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all packages in a user's namespace for which the requesting user has access.  OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_list_packages_for_user(configuration: &configuration::Configuration, package_type: &str, username: &str, visibility: Option<&str>, page: Option<i32>, per_page: Option<i32>) -> Result<Vec<models::Package>, Error<PackagesSlashListPackagesForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_username = username;
    let p_visibility = visibility;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/users/{username}/packages", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("package_type", &p_package_type.to_string())]);
    if let Some(ref param_value) = p_visibility {
        req_builder = req_builder.query(&[("visibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Package&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Package&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashListPackagesForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Restores a package owned by the authenticated user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_restore_package_for_authenticated_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str, token: Option<&str>) -> Result<(), Error<PackagesSlashRestorePackageForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_token = token;

    let uri_str = format!("{}/user/packages/{package_type}/{package_name}/restore", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_token {
        req_builder = req_builder.query(&[("token", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashRestorePackageForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Restores an entire package in an organization.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.  The authenticated user must have admin permissions in the organization to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_restore_package_for_org(configuration: &configuration::Configuration, package_type: &str, package_name: &str, org: &str, token: Option<&str>) -> Result<(), Error<PackagesSlashRestorePackageForOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_org = org;
    let p_token = token;

    let uri_str = format!("{}/orgs/{org}/packages/{package_type}/{package_name}/restore", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_token {
        req_builder = req_builder.query(&[("token", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashRestorePackageForOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Restores an entire package for a user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.  If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_restore_package_for_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str, username: &str, token: Option<&str>) -> Result<(), Error<PackagesSlashRestorePackageForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_username = username;
    let p_token = token;

    let uri_str = format!("{}/users/{username}/packages/{package_type}/{package_name}/restore", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_token {
        req_builder = req_builder.query(&[("token", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashRestorePackageForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Restores a package version owned by the authenticated user.  You can restore a deleted package version under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_restore_package_version_for_authenticated_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str, package_version_id: i32) -> Result<(), Error<PackagesSlashRestorePackageVersionForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_package_version_id = package_version_id;

    let uri_str = format!("{}/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), package_version_id=p_package_version_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashRestorePackageVersionForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Restores a specific package version in an organization.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.  The authenticated user must have admin permissions in the organization to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must also have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_restore_package_version_for_org(configuration: &configuration::Configuration, package_type: &str, package_name: &str, org: &str, package_version_id: i32) -> Result<(), Error<PackagesSlashRestorePackageVersionForOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_org = org;
    let p_package_version_id = package_version_id;

    let uri_str = format!("{}/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), org=crate::apis::urlencode(p_org), package_version_id=p_package_version_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashRestorePackageVersionForOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Restores a specific package version for a user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.  If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, the authenticated user must have admin permissions to the package. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"  OAuth app tokens and personal access tokens (classic) need the `read:packages` and `write:packages` scopes to use this endpoint. For more information, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"
pub async fn packages_slash_restore_package_version_for_user(configuration: &configuration::Configuration, package_type: &str, package_name: &str, username: &str, package_version_id: i32) -> Result<(), Error<PackagesSlashRestorePackageVersionForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_type = package_type;
    let p_package_name = package_name;
    let p_username = username;
    let p_package_version_id = package_version_id;

    let uri_str = format!("{}/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore", configuration.base_path, package_type=crate::apis::urlencode(p_package_type), package_name=crate::apis::urlencode(p_package_name), username=crate::apis::urlencode(p_username), package_version_id=p_package_version_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesSlashRestorePackageVersionForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

