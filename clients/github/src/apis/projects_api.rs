/*
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`projects_slash_add_collaborator`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashAddCollaboratorError {
    Status404(models::BasicError),
    Status422(models::ValidationError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_create_card`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashCreateCardError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status422(models::OrgsUpdate422Response),
    Status503(models::ProjectsMoveCard503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_create_column`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashCreateColumnError {
    Status403(models::BasicError),
    Status422(models::ValidationErrorSimple),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_create_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashCreateForAuthenticatedUserError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status422(models::ValidationErrorSimple),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_create_for_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashCreateForOrgError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status410(models::BasicError),
    Status422(models::ValidationErrorSimple),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_create_for_repo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashCreateForRepoError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status410(models::BasicError),
    Status422(models::ValidationErrorSimple),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashDeleteError {
    Status403(models::ProjectsDeleteCard403Response),
    Status401(models::BasicError),
    Status410(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_delete_card`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashDeleteCardError {
    Status403(models::ProjectsDeleteCard403Response),
    Status401(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_delete_column`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashDeleteColumnError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashGetError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_get_card`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashGetCardError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_get_column`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashGetColumnError {
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_get_permission_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashGetPermissionForUserError {
    Status404(models::BasicError),
    Status422(models::ValidationError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_list_cards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashListCardsError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_list_collaborators`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashListCollaboratorsError {
    Status404(models::BasicError),
    Status422(models::ValidationError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_list_columns`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashListColumnsError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_list_for_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashListForOrgError {
    Status422(models::ValidationErrorSimple),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_list_for_repo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashListForRepoError {
    Status401(models::BasicError),
    Status403(models::BasicError),
    Status404(models::BasicError),
    Status410(models::BasicError),
    Status422(models::ValidationErrorSimple),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_list_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashListForUserError {
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_move_card`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashMoveCardError {
    Status403(models::ProjectsMoveCard403Response),
    Status401(models::BasicError),
    Status503(models::ProjectsMoveCard503Response),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_move_column`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashMoveColumnError {
    Status403(models::BasicError),
    Status422(models::ValidationErrorSimple),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_remove_collaborator`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashRemoveCollaboratorError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status422(models::ValidationError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashUpdateError {
    Status404(),
    Status403(models::ProjectsDeleteCard403Response),
    Status401(models::BasicError),
    Status410(models::BasicError),
    Status422(models::ValidationErrorSimple),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_update_card`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashUpdateCardError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status404(models::BasicError),
    Status422(models::ValidationErrorSimple),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_slash_update_column`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSlashUpdateColumnError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}


/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_add_collaborator(configuration: &configuration::Configuration, project_id: i32, username: &str, projects_add_collaborator_request: Option<models::ProjectsAddCollaboratorRequest>) -> Result<(), Error<ProjectsSlashAddCollaboratorError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;
    let p_username = username;
    let p_projects_add_collaborator_request = projects_add_collaborator_request;

    let uri_str = format!("{}/projects/{project_id}/collaborators/{username}", configuration.base_path, project_id=p_project_id, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_add_collaborator_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashAddCollaboratorError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_create_card(configuration: &configuration::Configuration, column_id: i32, projects_create_card_request: models::ProjectsCreateCardRequest) -> Result<models::ProjectCard, Error<ProjectsSlashCreateCardError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_column_id = column_id;
    let p_projects_create_card_request = projects_create_card_request;

    let uri_str = format!("{}/projects/columns/{column_id}/cards", configuration.base_path, column_id=p_column_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_create_card_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectCard`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectCard`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashCreateCardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_create_column(configuration: &configuration::Configuration, project_id: i32, projects_update_column_request: models::ProjectsUpdateColumnRequest) -> Result<models::ProjectColumn, Error<ProjectsSlashCreateColumnError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;
    let p_projects_update_column_request = projects_update_column_request;

    let uri_str = format!("{}/projects/{project_id}/columns", configuration.base_path, project_id=p_project_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_update_column_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectColumn`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectColumn`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashCreateColumnError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_create_for_authenticated_user(configuration: &configuration::Configuration, projects_create_for_authenticated_user_request: models::ProjectsCreateForAuthenticatedUserRequest) -> Result<models::Project, Error<ProjectsSlashCreateForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_projects_create_for_authenticated_user_request = projects_create_for_authenticated_user_request;

    let uri_str = format!("{}/user/projects", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_create_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Project`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Project`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashCreateForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_create_for_org(configuration: &configuration::Configuration, org: &str, projects_create_for_org_request: models::ProjectsCreateForOrgRequest) -> Result<models::Project, Error<ProjectsSlashCreateForOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_projects_create_for_org_request = projects_create_for_org_request;

    let uri_str = format!("{}/orgs/{org}/projects", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_create_for_org_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Project`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Project`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashCreateForOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_create_for_repo(configuration: &configuration::Configuration, owner: &str, repo: &str, projects_create_for_org_request: models::ProjectsCreateForOrgRequest) -> Result<models::Project, Error<ProjectsSlashCreateForRepoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_projects_create_for_org_request = projects_create_for_org_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/projects", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_create_for_org_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Project`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Project`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashCreateForRepoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_delete(configuration: &configuration::Configuration, project_id: i32) -> Result<(), Error<ProjectsSlashDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;

    let uri_str = format!("{}/projects/{project_id}", configuration.base_path, project_id=p_project_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_delete_card(configuration: &configuration::Configuration, card_id: i32) -> Result<(), Error<ProjectsSlashDeleteCardError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_card_id = card_id;

    let uri_str = format!("{}/projects/columns/cards/{card_id}", configuration.base_path, card_id=p_card_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashDeleteCardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_delete_column(configuration: &configuration::Configuration, column_id: i32) -> Result<(), Error<ProjectsSlashDeleteColumnError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_column_id = column_id;

    let uri_str = format!("{}/projects/columns/{column_id}", configuration.base_path, column_id=p_column_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashDeleteColumnError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_get(configuration: &configuration::Configuration, project_id: i32) -> Result<models::Project, Error<ProjectsSlashGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;

    let uri_str = format!("{}/projects/{project_id}", configuration.base_path, project_id=p_project_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Project`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Project`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_get_card(configuration: &configuration::Configuration, card_id: i32) -> Result<models::ProjectCard, Error<ProjectsSlashGetCardError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_card_id = card_id;

    let uri_str = format!("{}/projects/columns/cards/{card_id}", configuration.base_path, card_id=p_card_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectCard`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectCard`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashGetCardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_get_column(configuration: &configuration::Configuration, column_id: i32) -> Result<models::ProjectColumn, Error<ProjectsSlashGetColumnError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_column_id = column_id;

    let uri_str = format!("{}/projects/columns/{column_id}", configuration.base_path, column_id=p_column_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectColumn`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectColumn`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashGetColumnError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_get_permission_for_user(configuration: &configuration::Configuration, project_id: i32, username: &str) -> Result<models::ProjectCollaboratorPermission, Error<ProjectsSlashGetPermissionForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;
    let p_username = username;

    let uri_str = format!("{}/projects/{project_id}/collaborators/{username}/permission", configuration.base_path, project_id=p_project_id, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectCollaboratorPermission`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectCollaboratorPermission`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashGetPermissionForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_list_cards(configuration: &configuration::Configuration, column_id: i32, archived_state: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::ProjectCard>, Error<ProjectsSlashListCardsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_column_id = column_id;
    let p_archived_state = archived_state;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/projects/columns/{column_id}/cards", configuration.base_path, column_id=p_column_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_archived_state {
        req_builder = req_builder.query(&[("archived_state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ProjectCard&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ProjectCard&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashListCardsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_list_collaborators(configuration: &configuration::Configuration, project_id: i32, affiliation: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::SimpleUser>, Error<ProjectsSlashListCollaboratorsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;
    let p_affiliation = affiliation;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/projects/{project_id}/collaborators", configuration.base_path, project_id=p_project_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_affiliation {
        req_builder = req_builder.query(&[("affiliation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashListCollaboratorsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_list_columns(configuration: &configuration::Configuration, project_id: i32, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::ProjectColumn>, Error<ProjectsSlashListColumnsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/projects/{project_id}/columns", configuration.base_path, project_id=p_project_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ProjectColumn&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ProjectColumn&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashListColumnsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_list_for_org(configuration: &configuration::Configuration, org: &str, state: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Project>, Error<ProjectsSlashListForOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_state = state;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/orgs/{org}/projects", configuration.base_path, org=crate::apis::urlencode(p_org));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Project&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Project&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashListForOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_list_for_repo(configuration: &configuration::Configuration, owner: &str, repo: &str, state: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Project>, Error<ProjectsSlashListForRepoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_state = state;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/projects", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Project&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Project&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashListForRepoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_list_for_user(configuration: &configuration::Configuration, username: &str, state: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Project>, Error<ProjectsSlashListForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_state = state;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/projects", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Project&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Project&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashListForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_move_card(configuration: &configuration::Configuration, card_id: i32, projects_move_card_request: models::ProjectsMoveCardRequest) -> Result<serde_json::Value, Error<ProjectsSlashMoveCardError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_card_id = card_id;
    let p_projects_move_card_request = projects_move_card_request;

    let uri_str = format!("{}/projects/columns/cards/{card_id}/moves", configuration.base_path, card_id=p_card_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_move_card_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashMoveCardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_move_column(configuration: &configuration::Configuration, column_id: i32, projects_move_column_request: models::ProjectsMoveColumnRequest) -> Result<serde_json::Value, Error<ProjectsSlashMoveColumnError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_column_id = column_id;
    let p_projects_move_column_request = projects_move_column_request;

    let uri_str = format!("{}/projects/columns/{column_id}/moves", configuration.base_path, column_id=p_column_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_move_column_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashMoveColumnError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_remove_collaborator(configuration: &configuration::Configuration, project_id: i32, username: &str) -> Result<(), Error<ProjectsSlashRemoveCollaboratorError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;
    let p_username = username;

    let uri_str = format!("{}/projects/{project_id}/collaborators/{username}", configuration.base_path, project_id=p_project_id, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashRemoveCollaboratorError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_update(configuration: &configuration::Configuration, project_id: i32, projects_update_request: Option<models::ProjectsUpdateRequest>) -> Result<models::Project, Error<ProjectsSlashUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;
    let p_projects_update_request = projects_update_request;

    let uri_str = format!("{}/projects/{project_id}", configuration.base_path, project_id=p_project_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Project`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Project`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_update_card(configuration: &configuration::Configuration, card_id: i32, projects_update_card_request: Option<models::ProjectsUpdateCardRequest>) -> Result<models::ProjectCard, Error<ProjectsSlashUpdateCardError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_card_id = card_id;
    let p_projects_update_card_request = projects_update_card_request;

    let uri_str = format!("{}/projects/columns/cards/{card_id}", configuration.base_path, card_id=p_card_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_update_card_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectCard`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectCard`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashUpdateCardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Closing down notice:** Projects (classic) is being deprecated in favor of the new Projects experience. > See the [changelog](https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/) for more information.
pub async fn projects_slash_update_column(configuration: &configuration::Configuration, column_id: i32, projects_update_column_request: models::ProjectsUpdateColumnRequest) -> Result<models::ProjectColumn, Error<ProjectsSlashUpdateColumnError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_column_id = column_id;
    let p_projects_update_column_request = projects_update_column_request;

    let uri_str = format!("{}/projects/columns/{column_id}", configuration.base_path, column_id=p_column_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_update_column_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectColumn`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectColumn`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsSlashUpdateColumnError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

