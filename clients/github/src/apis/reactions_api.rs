/*
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`reactions_slash_create_for_commit_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashCreateForCommitCommentError {
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_create_for_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashCreateForIssueError {
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_create_for_issue_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashCreateForIssueCommentError {
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_create_for_pull_request_review_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashCreateForPullRequestReviewCommentError {
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_create_for_release`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashCreateForReleaseError {
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_create_for_team_discussion_comment_in_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashCreateForTeamDiscussionCommentInOrgError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_create_for_team_discussion_comment_legacy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashCreateForTeamDiscussionCommentLegacyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_create_for_team_discussion_in_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashCreateForTeamDiscussionInOrgError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_create_for_team_discussion_legacy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashCreateForTeamDiscussionLegacyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_delete_for_commit_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashDeleteForCommitCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_delete_for_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashDeleteForIssueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_delete_for_issue_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashDeleteForIssueCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_delete_for_pull_request_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashDeleteForPullRequestCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_delete_for_release`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashDeleteForReleaseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_delete_for_team_discussion`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashDeleteForTeamDiscussionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_delete_for_team_discussion_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashDeleteForTeamDiscussionCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_list_for_commit_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashListForCommitCommentError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_list_for_issue`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashListForIssueError {
    Status404(models::BasicError),
    Status410(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_list_for_issue_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashListForIssueCommentError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_list_for_pull_request_review_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashListForPullRequestReviewCommentError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_list_for_release`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashListForReleaseError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_list_for_team_discussion_comment_in_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashListForTeamDiscussionCommentInOrgError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_list_for_team_discussion_comment_legacy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashListForTeamDiscussionCommentLegacyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_list_for_team_discussion_in_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashListForTeamDiscussionInOrgError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_slash_list_for_team_discussion_legacy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsSlashListForTeamDiscussionLegacyError {
    UnknownValue(serde_json::Value),
}


/// Create a reaction to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment). A response with an HTTP `200` status means that you already added the reaction type to this commit comment.
pub async fn reactions_slash_create_for_commit_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, comment_id: i64, reactions_create_for_commit_comment_request: models::ReactionsCreateForCommitCommentRequest) -> Result<models::Reaction, Error<ReactionsSlashCreateForCommitCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_comment_id = comment_id;
    let p_reactions_create_for_commit_comment_request = reactions_create_for_commit_comment_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/comments/{comment_id}/reactions", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), comment_id=p_comment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_reactions_create_for_commit_comment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Reaction`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Reaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashCreateForCommitCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a reaction to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue). A response with an HTTP `200` status means that you already added the reaction type to this issue.
pub async fn reactions_slash_create_for_issue(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, reactions_create_for_issue_request: models::ReactionsCreateForIssueRequest) -> Result<models::Reaction, Error<ReactionsSlashCreateForIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_reactions_create_for_issue_request = reactions_create_for_issue_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/reactions", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_reactions_create_for_issue_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Reaction`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Reaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashCreateForIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a reaction to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment). A response with an HTTP `200` status means that you already added the reaction type to this issue comment.
pub async fn reactions_slash_create_for_issue_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, comment_id: i64, reactions_create_for_issue_comment_request: models::ReactionsCreateForIssueCommentRequest) -> Result<models::Reaction, Error<ReactionsSlashCreateForIssueCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_comment_id = comment_id;
    let p_reactions_create_for_issue_comment_request = reactions_create_for_issue_comment_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), comment_id=p_comment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_reactions_create_for_issue_comment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Reaction`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Reaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashCreateForIssueCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a reaction to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request). A response with an HTTP `200` status means that you already added the reaction type to this pull request review comment.
pub async fn reactions_slash_create_for_pull_request_review_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, comment_id: i64, reactions_create_for_pull_request_review_comment_request: models::ReactionsCreateForPullRequestReviewCommentRequest) -> Result<models::Reaction, Error<ReactionsSlashCreateForPullRequestReviewCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_comment_id = comment_id;
    let p_reactions_create_for_pull_request_review_comment_request = reactions_create_for_pull_request_review_comment_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), comment_id=p_comment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_reactions_create_for_pull_request_review_comment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Reaction`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Reaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashCreateForPullRequestReviewCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a reaction to a [release](https://docs.github.com/rest/releases/releases#get-a-release). A response with a `Status: 200 OK` means that you already added the reaction type to this release.
pub async fn reactions_slash_create_for_release(configuration: &configuration::Configuration, owner: &str, repo: &str, release_id: i32, reactions_create_for_release_request: models::ReactionsCreateForReleaseRequest) -> Result<models::Reaction, Error<ReactionsSlashCreateForReleaseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_release_id = release_id;
    let p_reactions_create_for_release_request = reactions_create_for_release_request;

    let uri_str = format!("{}/repos/{owner}/{repo}/releases/{release_id}/reactions", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), release_id=p_release_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_reactions_create_for_release_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Reaction`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Reaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashCreateForReleaseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).  A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.  > [!NOTE] > You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.  OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
pub async fn reactions_slash_create_for_team_discussion_comment_in_org(configuration: &configuration::Configuration, org: &str, team_slug: &str, discussion_number: i32, comment_number: i32, reactions_create_for_team_discussion_comment_in_org_request: models::ReactionsCreateForTeamDiscussionCommentInOrgRequest) -> Result<models::Reaction, Error<ReactionsSlashCreateForTeamDiscussionCommentInOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_team_slug = team_slug;
    let p_discussion_number = discussion_number;
    let p_comment_number = comment_number;
    let p_reactions_create_for_team_discussion_comment_in_org_request = reactions_create_for_team_discussion_comment_in_org_request;

    let uri_str = format!("{}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", configuration.base_path, org=crate::apis::urlencode(p_org), team_slug=crate::apis::urlencode(p_team_slug), discussion_number=p_discussion_number, comment_number=p_comment_number);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_reactions_create_for_team_discussion_comment_in_org_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Reaction`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Reaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashCreateForTeamDiscussionCommentInOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new \"[Create reaction for a team discussion comment](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion-comment)\" endpoint.  Create a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).  A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.  OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
pub async fn reactions_slash_create_for_team_discussion_comment_legacy(configuration: &configuration::Configuration, team_id: i32, discussion_number: i32, comment_number: i32, reactions_create_for_team_discussion_comment_in_org_request: models::ReactionsCreateForTeamDiscussionCommentInOrgRequest) -> Result<models::Reaction, Error<ReactionsSlashCreateForTeamDiscussionCommentLegacyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_id = team_id;
    let p_discussion_number = discussion_number;
    let p_comment_number = comment_number;
    let p_reactions_create_for_team_discussion_comment_in_org_request = reactions_create_for_team_discussion_comment_in_org_request;

    let uri_str = format!("{}/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions", configuration.base_path, team_id=p_team_id, discussion_number=p_discussion_number, comment_number=p_comment_number);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_reactions_create_for_team_discussion_comment_in_org_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Reaction`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Reaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashCreateForTeamDiscussionCommentLegacyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).  A response with an HTTP `200` status means that you already added the reaction type to this team discussion.  > [!NOTE] > You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.  OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
pub async fn reactions_slash_create_for_team_discussion_in_org(configuration: &configuration::Configuration, org: &str, team_slug: &str, discussion_number: i32, reactions_create_for_team_discussion_in_org_request: models::ReactionsCreateForTeamDiscussionInOrgRequest) -> Result<models::Reaction, Error<ReactionsSlashCreateForTeamDiscussionInOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_team_slug = team_slug;
    let p_discussion_number = discussion_number;
    let p_reactions_create_for_team_discussion_in_org_request = reactions_create_for_team_discussion_in_org_request;

    let uri_str = format!("{}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", configuration.base_path, org=crate::apis::urlencode(p_org), team_slug=crate::apis::urlencode(p_team_slug), discussion_number=p_discussion_number);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_reactions_create_for_team_discussion_in_org_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Reaction`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Reaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashCreateForTeamDiscussionInOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create reaction for a team discussion`](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion) endpoint.  Create a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).  A response with an HTTP `200` status means that you already added the reaction type to this team discussion.  OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
pub async fn reactions_slash_create_for_team_discussion_legacy(configuration: &configuration::Configuration, team_id: i32, discussion_number: i32, reactions_create_for_team_discussion_in_org_request: models::ReactionsCreateForTeamDiscussionInOrgRequest) -> Result<models::Reaction, Error<ReactionsSlashCreateForTeamDiscussionLegacyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_id = team_id;
    let p_discussion_number = discussion_number;
    let p_reactions_create_for_team_discussion_in_org_request = reactions_create_for_team_discussion_in_org_request;

    let uri_str = format!("{}/teams/{team_id}/discussions/{discussion_number}/reactions", configuration.base_path, team_id=p_team_id, discussion_number=p_discussion_number);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_reactions_create_for_team_discussion_in_org_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Reaction`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Reaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashCreateForTeamDiscussionLegacyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.  Delete a reaction to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment).
pub async fn reactions_slash_delete_for_commit_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, comment_id: i64, reaction_id: i32) -> Result<(), Error<ReactionsSlashDeleteForCommitCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_comment_id = comment_id;
    let p_reaction_id = reaction_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), comment_id=p_comment_id, reaction_id=p_reaction_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashDeleteForCommitCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.  Delete a reaction to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue).
pub async fn reactions_slash_delete_for_issue(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, reaction_id: i32) -> Result<(), Error<ReactionsSlashDeleteForIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_reaction_id = reaction_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number, reaction_id=p_reaction_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashDeleteForIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.  Delete a reaction to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment).
pub async fn reactions_slash_delete_for_issue_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, comment_id: i64, reaction_id: i32) -> Result<(), Error<ReactionsSlashDeleteForIssueCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_comment_id = comment_id;
    let p_reaction_id = reaction_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), comment_id=p_comment_id, reaction_id=p_reaction_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashDeleteForIssueCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`  Delete a reaction to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request).
pub async fn reactions_slash_delete_for_pull_request_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, comment_id: i64, reaction_id: i32) -> Result<(), Error<ReactionsSlashDeleteForPullRequestCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_comment_id = comment_id;
    let p_reaction_id = reaction_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), comment_id=p_comment_id, reaction_id=p_reaction_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashDeleteForPullRequestCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/releases/:release_id/reactions/:reaction_id`.  Delete a reaction to a [release](https://docs.github.com/rest/releases/releases#get-a-release).
pub async fn reactions_slash_delete_for_release(configuration: &configuration::Configuration, owner: &str, repo: &str, release_id: i32, reaction_id: i32) -> Result<(), Error<ReactionsSlashDeleteForReleaseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_release_id = release_id;
    let p_reaction_id = reaction_id;

    let uri_str = format!("{}/repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), release_id=p_release_id, reaction_id=p_reaction_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashDeleteForReleaseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.  Delete a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).  OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
pub async fn reactions_slash_delete_for_team_discussion(configuration: &configuration::Configuration, org: &str, team_slug: &str, discussion_number: i32, reaction_id: i32) -> Result<(), Error<ReactionsSlashDeleteForTeamDiscussionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_team_slug = team_slug;
    let p_discussion_number = discussion_number;
    let p_reaction_id = reaction_id;

    let uri_str = format!("{}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}", configuration.base_path, org=crate::apis::urlencode(p_org), team_slug=crate::apis::urlencode(p_team_slug), discussion_number=p_discussion_number, reaction_id=p_reaction_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashDeleteForTeamDiscussionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!NOTE] > You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.  Delete a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).  OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
pub async fn reactions_slash_delete_for_team_discussion_comment(configuration: &configuration::Configuration, org: &str, team_slug: &str, discussion_number: i32, comment_number: i32, reaction_id: i32) -> Result<(), Error<ReactionsSlashDeleteForTeamDiscussionCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_team_slug = team_slug;
    let p_discussion_number = discussion_number;
    let p_comment_number = comment_number;
    let p_reaction_id = reaction_id;

    let uri_str = format!("{}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}", configuration.base_path, org=crate::apis::urlencode(p_org), team_slug=crate::apis::urlencode(p_team_slug), discussion_number=p_discussion_number, comment_number=p_comment_number, reaction_id=p_reaction_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashDeleteForTeamDiscussionCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the reactions to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment).
pub async fn reactions_slash_list_for_commit_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, comment_id: i64, content: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Reaction>, Error<ReactionsSlashListForCommitCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_comment_id = comment_id;
    let p_content = content;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/comments/{comment_id}/reactions", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), comment_id=p_comment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_content {
        req_builder = req_builder.query(&[("content", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashListForCommitCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the reactions to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue).
pub async fn reactions_slash_list_for_issue(configuration: &configuration::Configuration, owner: &str, repo: &str, issue_number: i32, content: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Reaction>, Error<ReactionsSlashListForIssueError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_issue_number = issue_number;
    let p_content = content;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/{issue_number}/reactions", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), issue_number=p_issue_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_content {
        req_builder = req_builder.query(&[("content", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashListForIssueError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the reactions to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment).
pub async fn reactions_slash_list_for_issue_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, comment_id: i64, content: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Reaction>, Error<ReactionsSlashListForIssueCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_comment_id = comment_id;
    let p_content = content;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), comment_id=p_comment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_content {
        req_builder = req_builder.query(&[("content", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashListForIssueCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the reactions to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request).
pub async fn reactions_slash_list_for_pull_request_review_comment(configuration: &configuration::Configuration, owner: &str, repo: &str, comment_id: i64, content: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Reaction>, Error<ReactionsSlashListForPullRequestReviewCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_comment_id = comment_id;
    let p_content = content;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), comment_id=p_comment_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_content {
        req_builder = req_builder.query(&[("content", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashListForPullRequestReviewCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the reactions to a [release](https://docs.github.com/rest/releases/releases#get-a-release).
pub async fn reactions_slash_list_for_release(configuration: &configuration::Configuration, owner: &str, repo: &str, release_id: i32, content: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Reaction>, Error<ReactionsSlashListForReleaseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_owner = owner;
    let p_repo = repo;
    let p_release_id = release_id;
    let p_content = content;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/repos/{owner}/{repo}/releases/{release_id}/reactions", configuration.base_path, owner=crate::apis::urlencode(p_owner), repo=crate::apis::urlencode(p_repo), release_id=p_release_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_content {
        req_builder = req_builder.query(&[("content", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashListForReleaseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the reactions to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).  > [!NOTE] > You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.  OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
pub async fn reactions_slash_list_for_team_discussion_comment_in_org(configuration: &configuration::Configuration, org: &str, team_slug: &str, discussion_number: i32, comment_number: i32, content: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Reaction>, Error<ReactionsSlashListForTeamDiscussionCommentInOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_team_slug = team_slug;
    let p_discussion_number = discussion_number;
    let p_comment_number = comment_number;
    let p_content = content;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", configuration.base_path, org=crate::apis::urlencode(p_org), team_slug=crate::apis::urlencode(p_team_slug), discussion_number=p_discussion_number, comment_number=p_comment_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_content {
        req_builder = req_builder.query(&[("content", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashListForTeamDiscussionCommentInOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion comment`](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion-comment) endpoint.  List the reactions to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).  OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
pub async fn reactions_slash_list_for_team_discussion_comment_legacy(configuration: &configuration::Configuration, team_id: i32, discussion_number: i32, comment_number: i32, content: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Reaction>, Error<ReactionsSlashListForTeamDiscussionCommentLegacyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_id = team_id;
    let p_discussion_number = discussion_number;
    let p_comment_number = comment_number;
    let p_content = content;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions", configuration.base_path, team_id=p_team_id, discussion_number=p_discussion_number, comment_number=p_comment_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_content {
        req_builder = req_builder.query(&[("content", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashListForTeamDiscussionCommentLegacyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the reactions to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).  > [!NOTE] > You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.  OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
pub async fn reactions_slash_list_for_team_discussion_in_org(configuration: &configuration::Configuration, org: &str, team_slug: &str, discussion_number: i32, content: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Reaction>, Error<ReactionsSlashListForTeamDiscussionInOrgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org = org;
    let p_team_slug = team_slug;
    let p_discussion_number = discussion_number;
    let p_content = content;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", configuration.base_path, org=crate::apis::urlencode(p_org), team_slug=crate::apis::urlencode(p_team_slug), discussion_number=p_discussion_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_content {
        req_builder = req_builder.query(&[("content", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashListForTeamDiscussionInOrgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// > [!WARNING] > **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion`](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion) endpoint.  List the reactions to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).  OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
pub async fn reactions_slash_list_for_team_discussion_legacy(configuration: &configuration::Configuration, team_id: i32, discussion_number: i32, content: Option<&str>, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Reaction>, Error<ReactionsSlashListForTeamDiscussionLegacyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_id = team_id;
    let p_discussion_number = discussion_number;
    let p_content = content;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/teams/{team_id}/discussions/{discussion_number}/reactions", configuration.base_path, team_id=p_team_id, discussion_number=p_discussion_number);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_content {
        req_builder = req_builder.query(&[("content", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Reaction&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactionsSlashListForTeamDiscussionLegacyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

