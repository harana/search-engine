/*
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`users_slash_add_email_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashAddEmailForAuthenticatedUserError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_add_social_account_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashAddSocialAccountForAuthenticatedUserError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_block`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashBlockError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_check_blocked`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashCheckBlockedError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_check_following_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashCheckFollowingForUserError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_check_person_is_followed_by_authenticated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashCheckPersonIsFollowedByAuthenticatedError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_create_gpg_key_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashCreateGpgKeyForAuthenticatedUserError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_create_public_ssh_key_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashCreatePublicSshKeyForAuthenticatedUserError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_create_ssh_signing_key_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashCreateSshSigningKeyForAuthenticatedUserError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_delete_email_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashDeleteEmailForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_delete_gpg_key_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashDeleteGpgKeyForAuthenticatedUserError {
    Status404(models::BasicError),
    Status422(models::ValidationError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_delete_public_ssh_key_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashDeletePublicSshKeyForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_delete_social_account_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashDeleteSocialAccountForAuthenticatedUserError {
    Status422(models::ValidationError),
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_delete_ssh_signing_key_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashDeleteSshSigningKeyForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_follow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashFollowError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_get_authenticated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashGetAuthenticatedError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_get_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashGetByIdError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_get_by_username`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashGetByUsernameError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_get_context_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashGetContextForUserError {
    Status404(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_get_gpg_key_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashGetGpgKeyForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_get_public_ssh_key_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashGetPublicSshKeyForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_get_ssh_signing_key_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashGetSshSigningKeyForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_attestations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListAttestationsError {
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_blocked_by_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListBlockedByAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_emails_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListEmailsForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_followed_by_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListFollowedByAuthenticatedUserError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_followers_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListFollowersForAuthenticatedUserError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_followers_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListFollowersForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_following_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListFollowingForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_gpg_keys_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListGpgKeysForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_gpg_keys_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListGpgKeysForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_public_emails_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListPublicEmailsForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_public_keys_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListPublicKeysForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_public_ssh_keys_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListPublicSshKeysForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_social_accounts_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListSocialAccountsForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_social_accounts_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListSocialAccountsForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_ssh_signing_keys_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListSshSigningKeysForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_list_ssh_signing_keys_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashListSshSigningKeysForUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_set_primary_email_visibility_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashSetPrimaryEmailVisibilityForAuthenticatedUserError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_unblock`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashUnblockError {
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status404(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_unfollow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashUnfollowError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_slash_update_authenticated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersSlashUpdateAuthenticatedError {
    Status404(models::BasicError),
    Status403(models::BasicError),
    Status401(models::BasicError),
    Status422(models::ValidationError),
    UnknownValue(serde_json::Value),
}


/// OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
pub async fn users_slash_add_email_for_authenticated_user(configuration: &configuration::Configuration, users_add_email_for_authenticated_user_request: Option<models::UsersAddEmailForAuthenticatedUserRequest>) -> Result<Vec<models::Email>, Error<UsersSlashAddEmailForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_users_add_email_for_authenticated_user_request = users_add_email_for_authenticated_user_request;

    let uri_str = format!("{}/user/emails", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_users_add_email_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Email&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Email&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashAddEmailForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add one or more social accounts to the authenticated user's profile.  OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
pub async fn users_slash_add_social_account_for_authenticated_user(configuration: &configuration::Configuration, users_add_social_account_for_authenticated_user_request: models::UsersAddSocialAccountForAuthenticatedUserRequest) -> Result<Vec<models::SocialAccount>, Error<UsersSlashAddSocialAccountForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_users_add_social_account_for_authenticated_user_request = users_add_social_account_for_authenticated_user_request;

    let uri_str = format!("{}/user/social_accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_users_add_social_account_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SocialAccount&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SocialAccount&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashAddSocialAccountForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Blocks the given user and returns a 204. If the authenticated user cannot block the given user a 422 is returned.
pub async fn users_slash_block(configuration: &configuration::Configuration, username: &str) -> Result<(), Error<UsersSlashBlockError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/user/blocks/{username}", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashBlockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a 204 if the given user is blocked by the authenticated user. Returns a 404 if the given user is not blocked by the authenticated user, or if the given user account has been identified as spam by GitHub.
pub async fn users_slash_check_blocked(configuration: &configuration::Configuration, username: &str) -> Result<(), Error<UsersSlashCheckBlockedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/user/blocks/{username}", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashCheckBlockedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn users_slash_check_following_for_user(configuration: &configuration::Configuration, username: &str, target_user: &str) -> Result<(), Error<UsersSlashCheckFollowingForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_target_user = target_user;

    let uri_str = format!("{}/users/{username}/following/{target_user}", configuration.base_path, username=crate::apis::urlencode(p_username), target_user=crate::apis::urlencode(p_target_user));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashCheckFollowingForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn users_slash_check_person_is_followed_by_authenticated(configuration: &configuration::Configuration, username: &str) -> Result<(), Error<UsersSlashCheckPersonIsFollowedByAuthenticatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/user/following/{username}", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashCheckPersonIsFollowedByAuthenticatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a GPG key to the authenticated user's GitHub account.  OAuth app tokens and personal access tokens (classic) need the `write:gpg_key` scope to use this endpoint.
pub async fn users_slash_create_gpg_key_for_authenticated_user(configuration: &configuration::Configuration, users_create_gpg_key_for_authenticated_user_request: models::UsersCreateGpgKeyForAuthenticatedUserRequest) -> Result<models::GpgKey, Error<UsersSlashCreateGpgKeyForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_users_create_gpg_key_for_authenticated_user_request = users_create_gpg_key_for_authenticated_user_request;

    let uri_str = format!("{}/user/gpg_keys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_users_create_gpg_key_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GpgKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GpgKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashCreateGpgKeyForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a public SSH key to the authenticated user's GitHub account.  OAuth app tokens and personal access tokens (classic) need the `write:gpg_key` scope to use this endpoint.
pub async fn users_slash_create_public_ssh_key_for_authenticated_user(configuration: &configuration::Configuration, users_create_public_ssh_key_for_authenticated_user_request: models::UsersCreatePublicSshKeyForAuthenticatedUserRequest) -> Result<models::Key, Error<UsersSlashCreatePublicSshKeyForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_users_create_public_ssh_key_for_authenticated_user_request = users_create_public_ssh_key_for_authenticated_user_request;

    let uri_str = format!("{}/user/keys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_users_create_public_ssh_key_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Key`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Key`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashCreatePublicSshKeyForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an SSH signing key for the authenticated user's GitHub account.  OAuth app tokens and personal access tokens (classic) need the `write:ssh_signing_key` scope to use this endpoint.
pub async fn users_slash_create_ssh_signing_key_for_authenticated_user(configuration: &configuration::Configuration, users_create_ssh_signing_key_for_authenticated_user_request: models::UsersCreateSshSigningKeyForAuthenticatedUserRequest) -> Result<models::SshSigningKey, Error<UsersSlashCreateSshSigningKeyForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_users_create_ssh_signing_key_for_authenticated_user_request = users_create_ssh_signing_key_for_authenticated_user_request;

    let uri_str = format!("{}/user/ssh_signing_keys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_users_create_ssh_signing_key_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SshSigningKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SshSigningKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashCreateSshSigningKeyForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
pub async fn users_slash_delete_email_for_authenticated_user(configuration: &configuration::Configuration, users_delete_email_for_authenticated_user_request: Option<models::UsersDeleteEmailForAuthenticatedUserRequest>) -> Result<(), Error<UsersSlashDeleteEmailForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_users_delete_email_for_authenticated_user_request = users_delete_email_for_authenticated_user_request;

    let uri_str = format!("{}/user/emails", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_users_delete_email_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashDeleteEmailForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a GPG key from the authenticated user's GitHub account.  OAuth app tokens and personal access tokens (classic) need the `admin:gpg_key` scope to use this endpoint.
pub async fn users_slash_delete_gpg_key_for_authenticated_user(configuration: &configuration::Configuration, gpg_key_id: i32) -> Result<(), Error<UsersSlashDeleteGpgKeyForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gpg_key_id = gpg_key_id;

    let uri_str = format!("{}/user/gpg_keys/{gpg_key_id}", configuration.base_path, gpg_key_id=p_gpg_key_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashDeleteGpgKeyForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a public SSH key from the authenticated user's GitHub account.  OAuth app tokens and personal access tokens (classic) need the `admin:public_key` scope to use this endpoint.
pub async fn users_slash_delete_public_ssh_key_for_authenticated_user(configuration: &configuration::Configuration, key_id: i32) -> Result<(), Error<UsersSlashDeletePublicSshKeyForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_key_id = key_id;

    let uri_str = format!("{}/user/keys/{key_id}", configuration.base_path, key_id=p_key_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashDeletePublicSshKeyForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes one or more social accounts from the authenticated user's profile.  OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
pub async fn users_slash_delete_social_account_for_authenticated_user(configuration: &configuration::Configuration, users_delete_social_account_for_authenticated_user_request: models::UsersDeleteSocialAccountForAuthenticatedUserRequest) -> Result<(), Error<UsersSlashDeleteSocialAccountForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_users_delete_social_account_for_authenticated_user_request = users_delete_social_account_for_authenticated_user_request;

    let uri_str = format!("{}/user/social_accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_users_delete_social_account_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashDeleteSocialAccountForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an SSH signing key from the authenticated user's GitHub account.  OAuth app tokens and personal access tokens (classic) need the `admin:ssh_signing_key` scope to use this endpoint.
pub async fn users_slash_delete_ssh_signing_key_for_authenticated_user(configuration: &configuration::Configuration, ssh_signing_key_id: i32) -> Result<(), Error<UsersSlashDeleteSshSigningKeyForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ssh_signing_key_id = ssh_signing_key_id;

    let uri_str = format!("{}/user/ssh_signing_keys/{ssh_signing_key_id}", configuration.base_path, ssh_signing_key_id=p_ssh_signing_key_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashDeleteSshSigningKeyForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).\"  OAuth app tokens and personal access tokens (classic) need the `user:follow` scope to use this endpoint.
pub async fn users_slash_follow(configuration: &configuration::Configuration, username: &str) -> Result<(), Error<UsersSlashFollowError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/user/following/{username}", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashFollowError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// OAuth app tokens and personal access tokens (classic) need the `user` scope in order for the response to include private profile information.
pub async fn users_slash_get_authenticated(configuration: &configuration::Configuration, ) -> Result<models::UsersGetAuthenticated200Response, Error<UsersSlashGetAuthenticatedError>> {

    let uri_str = format!("{}/user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsersGetAuthenticated200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsersGetAuthenticated200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashGetAuthenticatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides publicly available information about someone with a GitHub account. This method takes their durable user `ID` instead of their `login`, which can change over time.  If you are requesting information about an [Enterprise Managed User](https://docs.github.com/enterprise-cloud@latest/admin/managing-iam/understanding-iam-for-enterprises/about-enterprise-managed-users), or a GitHub App bot that is installed in an organization that uses Enterprise Managed Users, your requests must be authenticated as a user or GitHub App that has access to the organization to view that account's information. If you are not authorized, the request will return a `404 Not Found` status.  The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be public which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#authentication).  The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see [Emails API](https://docs.github.com/rest/users/emails).
pub async fn users_slash_get_by_id(configuration: &configuration::Configuration, account_id: i32) -> Result<models::UsersGetAuthenticated200Response, Error<UsersSlashGetByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;

    let uri_str = format!("{}/user/{account_id}", configuration.base_path, account_id=p_account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsersGetAuthenticated200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsersGetAuthenticated200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashGetByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides publicly available information about someone with a GitHub account.  If you are requesting information about an [Enterprise Managed User](https://docs.github.com/enterprise-cloud@latest/admin/managing-iam/understanding-iam-for-enterprises/about-enterprise-managed-users), or a GitHub App bot that is installed in an organization that uses Enterprise Managed Users, your requests must be authenticated as a user or GitHub App that has access to the organization to view that account's information. If you are not authorized, the request will return a `404 Not Found` status.  The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be public which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#authentication).  The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see [Emails API](https://docs.github.com/rest/users/emails).
pub async fn users_slash_get_by_username(configuration: &configuration::Configuration, username: &str) -> Result<models::UsersGetAuthenticated200Response, Error<UsersSlashGetByUsernameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/users/{username}", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsersGetAuthenticated200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsersGetAuthenticated200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashGetByUsernameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provides hovercard information. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.    The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about `octocat` who owns the `Spoon-Knife` repository, you would use a `subject_type` value of `repository` and a `subject_id` value of `1300192` (the ID of the `Spoon-Knife` repository).  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
pub async fn users_slash_get_context_for_user(configuration: &configuration::Configuration, username: &str, subject_type: Option<&str>, subject_id: Option<&str>) -> Result<models::Hovercard, Error<UsersSlashGetContextForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_subject_type = subject_type;
    let p_subject_id = subject_id;

    let uri_str = format!("{}/users/{username}/hovercard", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_subject_type {
        req_builder = req_builder.query(&[("subject_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_subject_id {
        req_builder = req_builder.query(&[("subject_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Hovercard`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Hovercard`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashGetContextForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// View extended details for a single GPG key.  OAuth app tokens and personal access tokens (classic) need the `read:gpg_key` scope to use this endpoint.
pub async fn users_slash_get_gpg_key_for_authenticated_user(configuration: &configuration::Configuration, gpg_key_id: i32) -> Result<models::GpgKey, Error<UsersSlashGetGpgKeyForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_gpg_key_id = gpg_key_id;

    let uri_str = format!("{}/user/gpg_keys/{gpg_key_id}", configuration.base_path, gpg_key_id=p_gpg_key_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GpgKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GpgKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashGetGpgKeyForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// View extended details for a single public SSH key.  OAuth app tokens and personal access tokens (classic) need the `read:public_key` scope to use this endpoint.
pub async fn users_slash_get_public_ssh_key_for_authenticated_user(configuration: &configuration::Configuration, key_id: i32) -> Result<models::Key, Error<UsersSlashGetPublicSshKeyForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_key_id = key_id;

    let uri_str = format!("{}/user/keys/{key_id}", configuration.base_path, key_id=p_key_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Key`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Key`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashGetPublicSshKeyForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets extended details for an SSH signing key.  OAuth app tokens and personal access tokens (classic) need the `read:ssh_signing_key` scope to use this endpoint.
pub async fn users_slash_get_ssh_signing_key_for_authenticated_user(configuration: &configuration::Configuration, ssh_signing_key_id: i32) -> Result<models::SshSigningKey, Error<UsersSlashGetSshSigningKeyForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ssh_signing_key_id = ssh_signing_key_id;

    let uri_str = format!("{}/user/ssh_signing_keys/{ssh_signing_key_id}", configuration.base_path, ssh_signing_key_id=p_ssh_signing_key_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SshSigningKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SshSigningKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashGetSshSigningKeyForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all users, in the order that they signed up on GitHub. This list includes personal user accounts and organization accounts.  Note: Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of users.
pub async fn users_slash_list(configuration: &configuration::Configuration, since: Option<i32>, per_page: Option<i32>) -> Result<Vec<models::SimpleUser>, Error<UsersSlashListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_since = since;
    let p_per_page = per_page;

    let uri_str = format!("{}/users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List a collection of artifact attestations with a given subject digest that are associated with repositories owned by a user.  The collection of attestations returned by this endpoint is filtered according to the authenticated user's permissions; if the authenticated user cannot read a repository, the attestations associated with that repository will not be included in the response. In addition, when using a fine-grained access token the `attestations:read` permission is required.  **Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
pub async fn users_slash_list_attestations(configuration: &configuration::Configuration, username: &str, subject_digest: &str, per_page: Option<i32>, before: Option<&str>, after: Option<&str>, predicate_type: Option<&str>) -> Result<models::OrgsListAttestations200Response, Error<UsersSlashListAttestationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_subject_digest = subject_digest;
    let p_per_page = per_page;
    let p_before = before;
    let p_after = after;
    let p_predicate_type = predicate_type;

    let uri_str = format!("{}/users/{username}/attestations/{subject_digest}", configuration.base_path, username=crate::apis::urlencode(p_username), subject_digest=crate::apis::urlencode(p_subject_digest));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_predicate_type {
        req_builder = req_builder.query(&[("predicate_type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrgsListAttestations200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrgsListAttestations200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListAttestationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the users you've blocked on your personal account.
pub async fn users_slash_list_blocked_by_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::SimpleUser>, Error<UsersSlashListBlockedByAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/blocks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListBlockedByAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all of your email addresses, and specifies which one is visible to the public.  OAuth app tokens and personal access tokens (classic) need the `user:email` scope to use this endpoint.
pub async fn users_slash_list_emails_for_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Email>, Error<UsersSlashListEmailsForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/emails", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Email&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Email&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListEmailsForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the people who the authenticated user follows.
pub async fn users_slash_list_followed_by_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowedByAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/following", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListFollowedByAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the people following the authenticated user.
pub async fn users_slash_list_followers_for_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowersForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/followers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListFollowersForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the people following the specified user.
pub async fn users_slash_list_followers_for_user(configuration: &configuration::Configuration, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowersForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/followers", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListFollowersForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the people who the specified user follows.
pub async fn users_slash_list_following_for_user(configuration: &configuration::Configuration, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::SimpleUser>, Error<UsersSlashListFollowingForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/following", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SimpleUser&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListFollowingForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the current user's GPG keys.  OAuth app tokens and personal access tokens (classic) need the `read:gpg_key` scope to use this endpoint.
pub async fn users_slash_list_gpg_keys_for_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::GpgKey>, Error<UsersSlashListGpgKeysForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/gpg_keys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GpgKey&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GpgKey&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListGpgKeysForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the GPG keys for a user. This information is accessible by anyone.
pub async fn users_slash_list_gpg_keys_for_user(configuration: &configuration::Configuration, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::GpgKey>, Error<UsersSlashListGpgKeysForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/gpg_keys", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GpgKey&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GpgKey&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListGpgKeysForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists your publicly visible email address, which you can set with the [Set primary email visibility for the authenticated user](https://docs.github.com/rest/users/emails#set-primary-email-visibility-for-the-authenticated-user) endpoint.  OAuth app tokens and personal access tokens (classic) need the `user:email` scope to use this endpoint.
pub async fn users_slash_list_public_emails_for_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Email>, Error<UsersSlashListPublicEmailsForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/public_emails", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Email&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Email&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListPublicEmailsForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
pub async fn users_slash_list_public_keys_for_user(configuration: &configuration::Configuration, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::KeySimple>, Error<UsersSlashListPublicKeysForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/keys", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::KeySimple&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::KeySimple&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListPublicKeysForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the public SSH keys for the authenticated user's GitHub account.  OAuth app tokens and personal access tokens (classic) need the `read:public_key` scope to use this endpoint.
pub async fn users_slash_list_public_ssh_keys_for_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::Key>, Error<UsersSlashListPublicSshKeysForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/keys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Key&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Key&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListPublicSshKeysForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all of your social accounts.
pub async fn users_slash_list_social_accounts_for_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::SocialAccount>, Error<UsersSlashListSocialAccountsForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/social_accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SocialAccount&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SocialAccount&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListSocialAccountsForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists social media accounts for a user. This endpoint is accessible by anyone.
pub async fn users_slash_list_social_accounts_for_user(configuration: &configuration::Configuration, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::SocialAccount>, Error<UsersSlashListSocialAccountsForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/social_accounts", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SocialAccount&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SocialAccount&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListSocialAccountsForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the SSH signing keys for the authenticated user's GitHub account.  OAuth app tokens and personal access tokens (classic) need the `read:ssh_signing_key` scope to use this endpoint.
pub async fn users_slash_list_ssh_signing_keys_for_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::SshSigningKey>, Error<UsersSlashListSshSigningKeysForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/user/ssh_signing_keys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SshSigningKey&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SshSigningKey&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListSshSigningKeysForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the SSH signing keys for a user. This operation is accessible by anyone.
pub async fn users_slash_list_ssh_signing_keys_for_user(configuration: &configuration::Configuration, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<Vec<models::SshSigningKey>, Error<UsersSlashListSshSigningKeysForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;
    let p_per_page = per_page;
    let p_page = page;

    let uri_str = format!("{}/users/{username}/ssh_signing_keys", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SshSigningKey&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SshSigningKey&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashListSshSigningKeysForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets the visibility for your primary email addresses.
pub async fn users_slash_set_primary_email_visibility_for_authenticated_user(configuration: &configuration::Configuration, users_set_primary_email_visibility_for_authenticated_user_request: models::UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequest) -> Result<Vec<models::Email>, Error<UsersSlashSetPrimaryEmailVisibilityForAuthenticatedUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_users_set_primary_email_visibility_for_authenticated_user_request = users_set_primary_email_visibility_for_authenticated_user_request;

    let uri_str = format!("{}/user/email/visibility", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_users_set_primary_email_visibility_for_authenticated_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Email&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Email&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashSetPrimaryEmailVisibilityForAuthenticatedUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unblocks the given user and returns a 204.
pub async fn users_slash_unblock(configuration: &configuration::Configuration, username: &str) -> Result<(), Error<UsersSlashUnblockError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/user/blocks/{username}", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashUnblockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// OAuth app tokens and personal access tokens (classic) need the `user:follow` scope to use this endpoint.
pub async fn users_slash_unfollow(configuration: &configuration::Configuration, username: &str) -> Result<(), Error<UsersSlashUnfollowError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/user/following/{username}", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashUnfollowError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// **Note:** If your email is set to private and you send an `email` parameter as part of this request to update your profile, your privacy settings are still enforced: the email address will not be displayed on your public profile or via the API.
pub async fn users_slash_update_authenticated(configuration: &configuration::Configuration, users_update_authenticated_request: Option<models::UsersUpdateAuthenticatedRequest>) -> Result<models::PrivateUser, Error<UsersSlashUpdateAuthenticatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_users_update_authenticated_request = users_update_authenticated_request;

    let uri_str = format!("{}/user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_users_update_authenticated_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PrivateUser`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PrivateUser`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersSlashUpdateAuthenticatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

